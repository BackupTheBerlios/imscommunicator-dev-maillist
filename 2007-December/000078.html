<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Imscommunicator-dev] r89 - in trunk: ims-communicator	ims-communicator/src/net/java/sip/communicator	ims-communicator/src/net/java/sip/communicator/sip	ims-communicator/src/net/java/sip/communicator/sip/reg	ims-communicator/src/net/java/sip/communicator/sip/security releases
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/imscommunicator-dev/2007-December/index.html" >
   <LINK REL="made" HREF="mailto:imscommunicator-dev%40lists.berlios.de?Subject=Re%3A%20%5BImscommunicator-dev%5D%20r89%20-%20in%20trunk%3A%20ims-communicator%0A%09ims-communicator/src/net/java/sip/communicator%0A%09ims-communicator/src/net/java/sip/communicator/sip%0A%09ims-communicator/src/net/java/sip/communicator/sip/reg%0A%09ims-communicator/src/net/java/sip/communicator/sip/security%20releases&In-Reply-To=%3C200712111755.lBBHt9Ch029678%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000076.html">
   <LINK REL="Next"  HREF="000077.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Imscommunicator-dev] r89 - in trunk: ims-communicator	ims-communicator/src/net/java/sip/communicator	ims-communicator/src/net/java/sip/communicator/sip	ims-communicator/src/net/java/sip/communicator/sip/reg	ims-communicator/src/net/java/sip/communicator/sip/security releases</H1>
    <B>jmfreitas at mail.berlios.de</B> 
    <A HREF="mailto:imscommunicator-dev%40lists.berlios.de?Subject=Re%3A%20%5BImscommunicator-dev%5D%20r89%20-%20in%20trunk%3A%20ims-communicator%0A%09ims-communicator/src/net/java/sip/communicator%0A%09ims-communicator/src/net/java/sip/communicator/sip%0A%09ims-communicator/src/net/java/sip/communicator/sip/reg%0A%09ims-communicator/src/net/java/sip/communicator/sip/security%20releases&In-Reply-To=%3C200712111755.lBBHt9Ch029678%40sheep.berlios.de%3E"
       TITLE="[Imscommunicator-dev] r89 - in trunk: ims-communicator	ims-communicator/src/net/java/sip/communicator	ims-communicator/src/net/java/sip/communicator/sip	ims-communicator/src/net/java/sip/communicator/sip/reg	ims-communicator/src/net/java/sip/communicator/sip/security releases">jmfreitas at mail.berlios.de
       </A><BR>
    <I>Tue Dec 11 18:55:09 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000076.html">[Imscommunicator-dev] r88 - in trunk:	ims-communicator/src/net/java/sip/communicator/media	ims-communicator/src/net/java/sip/communicator/sip	ims-communicator/src/net/java/sip/communicator/sip/reg	ims-communicator/src/net/java/sip/communicator/sip/security releases
</A></li>
        <LI>Next message: <A HREF="000077.html">[Imscommunicator-dev] r90 - trunk/lib
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#78">[ date ]</a>
              <a href="thread.html#78">[ thread ]</a>
              <a href="subject.html#78">[ subject ]</a>
              <a href="author.html#78">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jmfreitas
Date: 2007-12-11 18:46:19 +0100 (Tue, 11 Dec 2007)
New Revision: 89

Added:
   trunk/ims-communicator/src/net/java/sip/communicator/sip/security/Base64Coder.java
Removed:
   trunk/ims-communicator/src/net/java/sip/communicator/sip/security/Base64.java
Modified:
   trunk/ims-communicator/ims-communicator.xml
   trunk/ims-communicator/src/net/java/sip/communicator/SipCommunicator.java
   trunk/ims-communicator/src/net/java/sip/communicator/sip/CallProcessing.java
   trunk/ims-communicator/src/net/java/sip/communicator/sip/SipManager.java
   trunk/ims-communicator/src/net/java/sip/communicator/sip/reg/RegEventSubscription.java
   trunk/ims-communicator/src/net/java/sip/communicator/sip/security/AKADigest.java
   trunk/ims-communicator/src/net/java/sip/communicator/sip/security/Milenage.java
   trunk/ims-communicator/src/net/java/sip/communicator/sip/security/SipSecurityManager.java
   trunk/releases/ims-communicator-linux.zip
   trunk/releases/ims-communicator-windows.zip
Log:
- AKA XMAC bug
- AKA SQN check and synchronization failure message (AUTS)
- transparently set network interface to use

Modified: trunk/ims-communicator/ims-communicator.xml
===================================================================
--- trunk/ims-communicator/ims-communicator.xml	2007-12-05 16:59:53 UTC (rev 88)
+++ trunk/ims-communicator/ims-communicator.xml	2007-12-11 17:46:19 UTC (rev 89)
@@ -162,7 +162,7 @@
                 &lt;DEBUG_LOG value=&quot;log/ims-communicator.debug.log&quot;/&gt;
                 &lt;BAD_MESSAGE_LOG value=&quot;log/ims-communicator.ignored.log&quot;/&gt;
 				&lt;!-- TRACE_LEVEL: 16 for stack log..  or 32 for both stack and debug log/--&gt;
-                &lt;TRACE_LEVEL value=&quot;32&quot;/&gt;
+                &lt;TRACE_LEVEL value=&quot;16&quot;/&gt;
             &lt;/sip&gt;
         &lt;/javax&gt;
     &lt;/nist&gt;

Modified: trunk/ims-communicator/src/net/java/sip/communicator/SipCommunicator.java
===================================================================
--- trunk/ims-communicator/src/net/java/sip/communicator/SipCommunicator.java	2007-12-05 16:59:53 UTC (rev 88)
+++ trunk/ims-communicator/src/net/java/sip/communicator/SipCommunicator.java	2007-12-11 17:46:19 UTC (rev 89)
@@ -199,12 +199,10 @@
             NetworkAddressManager.start();
 
             
-
-            
             // issued by Miguel Freitas //
             // force first launch if network interfaces are different
-            String stackIPAddr 
-            	= Utils.getProperty(&quot;javax.sip.IP_ADDRESS&quot;);
+            /*
+            String stackIPAddr = Utils.getProperty(&quot;javax.sip.IP_ADDRESS&quot;);
             String prefIPAddr 
         		= Utils.getProperty(&quot;net.java.sip.communicator.common.PREFERRED_NETWORK_ADDRESS&quot;);
             if (stackIPAddr != null &amp;&amp; prefIPAddr != null)
@@ -215,6 +213,7 @@
             		PropertiesDepot.storeProperties();
             	}
             }
+            */
             // end //
             
             
@@ -227,6 +226,22 @@
 	             PropertiesDepot.setProperty(&quot;net.java.sip.communicator.FIRST_LAUNCH&quot;, &quot;false&quot;);
 	             PropertiesDepot.storeProperties();
             }
+            // issued by Miguel Freitas //
+            // (silently) setup correct IP address
+            else
+            {
+                InetAddress localhost = NetworkAddressManager.getLocalHost(false);
+                String ip = localhost.toString();
+                if (ip.indexOf(&quot;/&quot;) != -1)
+                	ip = ip.substring(ip.indexOf(&quot;/&quot;)+1, ip.length());
+                PropertiesDepot.setProperty(&quot;javax.sip.IP_ADDRESS&quot;, ip);
+                PropertiesDepot.setProperty(&quot;net.java.sip.communicator.common.PREFERRED_NETWORK_ADDRESS&quot;, ip);
+                PropertiesDepot.storeProperties();
+                console.debug(&quot;IP Address set to &quot; + ip);
+            }
+            
+            System.out.println(&quot;Using Interface &quot; + PropertiesDepot.getProperty(&quot;javax.sip.IP_ADDRESS&quot;));
+            // end //
   
             
             
@@ -1106,7 +1121,7 @@
                                        evt.getReason());
             else
             	guiManager.setGlobalStatus(GuiManager.NOT_REGISTERED,
-                        &quot;reason unknown&quot;);
+                        &quot;reason unknown/cancelled&quot;);
             // end //
             
             //we could now exit

Modified: trunk/ims-communicator/src/net/java/sip/communicator/sip/CallProcessing.java
===================================================================
--- trunk/ims-communicator/src/net/java/sip/communicator/sip/CallProcessing.java	2007-12-05 16:59:53 UTC (rev 88)
+++ trunk/ims-communicator/src/net/java/sip/communicator/sip/CallProcessing.java	2007-12-11 17:46:19 UTC (rev 89)
@@ -4006,13 +4006,14 @@
             ReasonHeader reason = (ReasonHeader)byeRequest.getHeader(ReasonHeader.NAME);
             if (reason != null)
             {
-            	String message = &quot;&quot;;
+            	String message = &quot;Received a Bye request with the folowing reason: \n&quot;;
             	message = message.concat( (reason.getProtocol()!=null) ? reason.getProtocol() : &quot;&quot; );
             	message = message.concat(String.valueOf(reason.getCause()));
             	message = message.concat( (reason.getText()!=null) ? reason.getText() : &quot;&quot; );
-            	            	
-                sipManCallback.fireCallRejectedRemotely(message, byeRequest);
             	
+            	Console.showDetailedMsg(&quot;Reason&quot;, message, byeRequest.toString());
+                //sipManCallback.fireCallRejectedRemotely(message, byeRequest);
+            	
             }
             // end //
             

Modified: trunk/ims-communicator/src/net/java/sip/communicator/sip/SipManager.java
===================================================================
--- trunk/ims-communicator/src/net/java/sip/communicator/sip/SipManager.java	2007-12-05 16:59:53 UTC (rev 88)
+++ trunk/ims-communicator/src/net/java/sip/communicator/sip/SipManager.java	2007-12-11 17:46:19 UTC (rev 89)
@@ -107,7 +107,7 @@
 {
 	
 	//  issued by Miguel Freitas
-	static private String IMSCommUserAgent = &quot;IMS-Communicator 071205&quot;;
+	static private String IMSCommUserAgent = &quot;IMS-Communicator 071211&quot;;
 	// end //
 	
 	
@@ -1863,13 +1863,15 @@
 	        		Utils.setProperty
 	                	(&quot;gov.nist.javax.sip.TRACE_LEVEL&quot;, &quot;16&quot;);
 	        	}
+	        	/*
 	        	else {
 	        		Utils.setProperty
 	                	(&quot;gov.nist.javax.sip.TRACE_LEVEL&quot;, &quot;32&quot;);
-	        		if (console.isDebugEnabled()) {
-	                    console.debug(&quot;debug log=&quot; + debugLog);
-	                }
 	        	}
+	        	*/
+	        	if (console.isDebugEnabled()) {
+                    console.debug(&quot;debug log=&quot; + debugLog);
+                }
 	        }
             /*String serverLog = Utils.getProperty
                 (&quot;gov.nist.javax.sip.SERVER_LOG&quot;);

Modified: trunk/ims-communicator/src/net/java/sip/communicator/sip/reg/RegEventSubscription.java
===================================================================
--- trunk/ims-communicator/src/net/java/sip/communicator/sip/reg/RegEventSubscription.java	2007-12-05 16:59:53 UTC (rev 88)
+++ trunk/ims-communicator/src/net/java/sip/communicator/sip/reg/RegEventSubscription.java	2007-12-11 17:46:19 UTC (rev 89)
@@ -611,6 +611,7 @@
 	                		
                 			sipManCallback.fireUnregistered(aor);
                 			Console.showDetailedMsg(
+                					&quot;User de-registered!&quot;,
                 	                &quot;Registration terminated by the network!\n&quot;
                 					+ &quot;URI &quot; + aor + &quot; de-registered.&quot;,
                 					notification.toString());

Modified: trunk/ims-communicator/src/net/java/sip/communicator/sip/security/AKADigest.java
===================================================================
--- trunk/ims-communicator/src/net/java/sip/communicator/sip/security/AKADigest.java	2007-12-05 16:59:53 UTC (rev 88)
+++ trunk/ims-communicator/src/net/java/sip/communicator/sip/security/AKADigest.java	2007-12-11 17:46:19 UTC (rev 89)
@@ -22,16 +22,10 @@
 
 package net.java.sip.communicator.sip.security;
 
-import gov.nist.javax.sip.header.ims.SecurityClientHeader;
-import gov.nist.javax.sip.header.ims.SecurityClientList;
-import gov.nist.javax.sip.header.ims.SecurityServerHeader;
-import gov.nist.javax.sip.header.ims.SecurityServerList;
-import gov.nist.javax.sip.header.ims.SecurityVerifyHeader;
-import gov.nist.javax.sip.header.ims.SecurityVerifyList;
+import java.lang.reflect.Array;
+import java.security.InvalidKeyException;
+import java.util.Vector;
 
-import java.security.*;
-import java.util.Iterator;
-
 import net.java.sip.communicator.common.Console;
 import net.java.sip.communicator.common.PropertiesDepot;
 import net.java.sip.communicator.common.Utils;
@@ -52,19 +46,24 @@
 {
     private static Console console = Console.getConsole(AKADigest.class);
 
-    //public static AKARES akaRes = null;
     
     public static final int RANDLEN = 16;	// 128 bits
     public static final int AUTNLEN = 16;	// 128 bits
+    public static final int AUTSLEN = 14;	// 112 bits
     public static final int SQNLEN 	= 6;	// 48 bits
+    public static final int AKLEN 	= 6;	// 48 bits
     public static final int AMFLEN 	= 2;	// 16 bits
     public static final int MACLEN 	= 8;	// 64 bits
-    public static final int CK 		= 16;	// 128 bits
-    public static final int IK 		= 16;	// 128 bits
+    public static final int CKLEN	= 16;	// 128 bits
+    public static final int IKLEN	= 16;	// 128 bits
     public static final int KLEN	= 16;	// 128 bits
     public static final int RESLEN	= 8;	// 64 bits
+    public static final int OPLEN	= 16;	// 128 bits
     
+    public static final int INDLEN 	= 5;	// 5 bits!!!
     
+    private static final int delta = 2^28;
+    
 	private static byte[] opc = null;
 	private static byte[] sharedSecret16 = null;
 	
@@ -85,7 +84,7 @@
 	    	// -&gt; nonce is in Base64 -&gt; decode it!
 	    	byte[] nonceBytes;
 	    	try {
-	    		nonceBytes = Base64.decodeToByte(nonce64);
+	    		nonceBytes = Base64Coder.decode(nonce64);
 	    	}
 	    	catch (Exception ex)
 	    	{
@@ -188,56 +187,46 @@
 	    	}
 	    	
 	    	
-	    	
-
-	    	// authenticate network
-	    	if (!networkAuthenticated(randBytes, autnBytes)) 
-	    	{
-	    		console.debug(&quot;Network was not authenticated! TODO: send &lt;User Authentication Reject&gt;&quot;);
-	    		// TODO: handle network authentication error!
-	    		// send &quot;User Authentication Reject&quot;
-	    		
-	    	}
-	    	else
-	    	{
-	    		console.debug(&quot;Network is authenticated. Proceeding with secure registration...&quot;);
-	    		
-	    	}
-	    	
-	    	
-	    	// TODO: check server SQN (received)
+	    	// check server SQN (received)
 	    	// determine server SQN (based on the AUTN received)
 	        // if within expected range (== to client SQN), generate RES
-	        // if not, produce AUTS using shared secret K and client SQN
-	        if (!sqnVerified(randBytes, autnBytes))
+	        // if not, produce AUTS using shared secret K and client SQN (and set RES=&quot;&quot;)
+	        if (!sqnVerified(akaRes, randBytes, autnBytes))
 	        {
-	        	console.debug(&quot;SQN not in the correct range! TODO: send &lt;synchronisation failure&gt;&quot;);
-	        	// TODO: send &lt;synchronisation failure&gt;
+	        	console.debug(&quot;SQN not in the correct range! sending &lt;synchronisation failure&gt;&quot;);
+
+	        	akaRes.setAUTS( generateAUTS(akaRes, sharedSecret16, randBytes) );
 	        	
-	        	// TODO: calculate AUTS
-	        	akaRes.setAUTS(new String(&quot;dummy&quot;).getBytes());
-	        	
 	        }
 	        else
 	        {
-	        	//console.debug(&quot;SQN in the correct range. Proceeding with secure registration...&quot;);
+	        	console.debug(&quot;SQN in the correct range. Proceeding with secure registration...&quot;);
+	        	// reset possible previous AUTS
 	        	akaRes.setAUTS(null);
+	        	
+	        	
+	        	
+		    	// authenticate network
+		    	if (!networkAuthenticated(randBytes, autnBytes)) 
+		    	{
+		    		console.debug(&quot;Network was not authenticated! TODO: send &lt;User Authentication Reject&gt;&quot;);
+		    		// handle network authentication error!
+		    		// TODO: send &quot;User Authentication Reject&quot;
+		    	}
+		    	else
+		    	{
+		    		console.debug(&quot;Network is authenticated. Proceeding with secure registration...&quot;);
+		    	}
 	        }
-
 	    	
-	    	
-	    	
-	    	
-	    	
 	        // generate RES
 	        // if AUTS != null, RES is generated with RAND and empty shared secret K (&quot;&quot;)
 	        // else, RES is generated with RAND and shared secret K
 	        
 	    	if (akaRes.getAUTS() == null
-	    			|| akaRes.getAUTS().length == 0)
+	    			|| akaRes.getAUTS().length() == 0)
 	    	{
 	    		console.debug(&quot;SQN in the expected range (and AUTS == null)&quot;);
-	    		console.debug(&quot;&gt; generate RES with RAND and K (f2)&quot;);
 	    		
 	    		try {
 	    			byte[] password = Milenage.f2(
@@ -245,7 +234,7 @@
 	    					randBytes,
 	    					opc);
 	    			//console.debug(&quot;password length = &quot; + password.length);
-	    			console.debug(&quot;password hex = &quot; 
+	    			console.debug(&quot;AKA RES hex = &quot; 
 	    					+ MessageDigestAlgorithm.toHexString(password));
 	    			
 	    			// possible point of break !
@@ -277,7 +266,22 @@
 	    	}
 	    	else {
 	    		// TODO: in case AUTS != null, generate new SQN
-	    		console.debug(&quot;akaRes.getAUTS() != null -&gt; TODO: generate new SQN !&quot;);
+	    		console.debug(&quot;Sending &lt;Synchronization Failure&gt;&quot;);
+	    		console.debug(&quot;AUTS (base64) = &quot; + akaRes.getAUTS());
+	    		
+	    		// Authorization &quot;auts&quot; parameter will be sent
+	    		// RES is generated with RAND and empty shared secret K (&quot;&quot;)
+	    		try {
+	    			akaRes.setAKARES(
+	    					Milenage.f2(new byte[KLEN],
+	    							randBytes,
+	    							opc));
+	    		}
+	    		catch (Exception ex)
+	    		{
+	    			console.error(&quot;Exception generating the AKA RES!&quot;);
+		    		throw new SipSecurityException(&quot;Exception generating the AKA RES! : &quot; + ex);
+	    		}
 	    	}
 	    	
 	    	
@@ -293,6 +297,59 @@
     }
     
     
+    /**
+     * Generate AUTS for Synchronization failure message.
+     * @param sharedSecret
+     * @param randBytes
+     * @param sqnMS
+     * @return &quot;auts&quot; parameter (base64)
+     */
+    private static String generateAUTS(AKARES akaRes, byte[] sharedSecret, byte[] randBytes)
+    	throws SipSecurityException
+    {
+    	try
+    	{
+    		console.logEntry();
+    		
+	    	// use dummy AMF value of all zeros
+	    	byte[] amf = new byte[AMFLEN];
+	    	// get SQN_MS
+	    	byte[] sqnMS = akaRes.getLastUsedSQN();
+	    	console.debug(&quot;USIM SQN (hex): &quot; + MessageDigestAlgorithm.toHexString(sqnMS));
+	    	
+	    	try {
+	    		// MAC-S
+				byte[] macS = Milenage.f1star(sharedSecret, randBytes, opc, sqnMS, amf);
+				console.debug(&quot;AUTS MAC-S (hex): &quot; + MessageDigestAlgorithm.toHexString(macS));
+				
+				// SQN_MS xor AK
+				byte[] ak = Milenage.f5star(sharedSecret, randBytes, opc);
+				byte[] sqnMSXorAK = xorArray(sqnMS, ak);
+
+				//AUTS = (SQN_MS xor AK) || MAC-S
+				byte[] auts = new byte[AUTSLEN];
+				for (int i=0; i&lt;SQNLEN; i++) {
+					auts[i] = sqnMSXorAK[i];
+				}
+				for (int i=SQNLEN, j=0; i&lt;AUTSLEN &amp;&amp; j&lt;MACLEN; i++, j++) {
+					auts[i] = macS[j];
+				}
+				
+				// Authorization &quot;auts&quot; parameter encoded in Base64
+				//return Base64.encode(new String(auts));
+				return Base64Coder.encodeBytes(auts);
+			} 
+	    	catch (Exception ex) {
+	    		console.error(&quot;Exception generating AUTS!&quot;, ex);
+	    		throw new SipSecurityException(&quot;Exception generating AUTS: &quot; + ex);
+			}
+    	}
+    	finally{
+    		console.logExit();
+    	}
+    	
+    	
+    }
     
     
 
@@ -345,16 +402,26 @@
 				byte[] akBytes = Milenage.f5(sharedSecret16, randBytes, opc);
 				console.debug(&quot;AK hex = &quot; + MessageDigestAlgorithm.toHexString(akBytes) + &quot; (&quot; + akBytes.length + &quot;bytes)&quot;);
 				
-				// SQN = (SQN xor AK) xor AK
-				sqnBytes = xorArray( xorArray(sqnBytes,akBytes), akBytes );
+				// SQN = (SQNxorAK) xor AK
+				sqnBytes = xorArray(sqnXorAkBytes, akBytes);
 				console.debug(&quot;SQN hex = &quot; + MessageDigestAlgorithm.toHexString(sqnBytes) + &quot; (&quot; + sqnBytes.length + &quot;bytes)&quot;);
 				
 				byte[] xmacBytes = Milenage.f1(sharedSecret16, randBytes, opc, sqnBytes, amfBytes);
 				console.debug(&quot;XMAC hex = &quot; + MessageDigestAlgorithm.toHexString(xmacBytes) + &quot; (&quot; + xmacBytes.length + &quot;bytes)&quot;);
 				
 				// MAC == XMAC?
-				if (xmacBytes == macBytes)
-					return true;
+				// compare the two byte array elements
+				for (int i = 0; i &lt; MACLEN; i++)
+				{
+					Byte macByte = new Byte(macBytes[i]);
+					Byte xmacByte = new Byte(xmacBytes[i]);
+					// if != 0, the bytes don't match
+					if (macByte.compareTo(xmacByte) != 0)
+						return false;
+					
+				}
+				console.debug(&quot;MAC == XMAC&quot;);
+				return true;
 				
 				
 			} catch (Exception ex) {
@@ -362,7 +429,6 @@
 	    		throw new SipSecurityException(&quot;Exception authenticating the network! : &quot; + ex);
 			}
 	    	
-	    	return false;
     	}
     	finally {
     		console.logExit();
@@ -371,22 +437,80 @@
     
     
     /**
-     * Verify if SQN is in the correct range.
+     * Verify if SQN is in the correct range (TS 33.102 Annex C).
      * @param randBytes
      * @param autnBytes
      * @return true if SQN is in the correct range.
      * @throws SipSecurityException
      */
-    private static boolean sqnVerified(byte[] randBytes, byte[] autnBytes)
+    private static boolean sqnVerified(AKARES akaRes, byte[] randBytes, byte[] autnBytes)
     	throws SipSecurityException
     {
     	try {
     		console.logEntry();
-    		
-	    	// TODO: Verify SQN
-	    	console.debug(&quot;TODO: Verify SQN...&quot;);
+
+    		byte[] sqnXorAkBytes = new byte[SQNLEN];
+    		int k = 0;
+	    	for (int i = 0; i&lt;SQNLEN; i++, k++)
+	    		sqnXorAkBytes[i] = autnBytes[k];
 	    	
-	    	return true;
+	    	byte[] sqnHEBytes = sqnXorAkBytes.clone();
+	    	int sqnHELong = 0;
+	    	try {
+	    		// AK = f5K(RAND)
+				byte[] akBytes = Milenage.f5(sharedSecret16, randBytes, opc);
+				//console.debug(&quot;AK hex = &quot; + MessageDigestAlgorithm.toHexString(akBytes) + &quot; (&quot; + akBytes.length + &quot;bytes)&quot;);
+				
+				// SQN = (SQNxorAK) xor AK
+				sqnHEBytes = xorArray(sqnXorAkBytes, akBytes);
+				console.debug(&quot;SQN_HE hex = &quot; + MessageDigestAlgorithm.toHexString(sqnHEBytes) + &quot; (&quot; + sqnHEBytes.length + &quot;bytes)&quot;);
+				
+				sqnHELong = AKADigest.bin2long(sqnHEBytes);
+				console.debug(&quot;SQN_HE long = &quot; + sqnHELong);
+				
+	    	}
+	    	catch (Exception ex) {
+	    		console.error(&quot;Exception authenticating the network!&quot;);
+	    		throw new SipSecurityException(&quot;Exception authenticating the network! : &quot; + ex);
+	    	}
+	    	
+	    	// SQN = SEQ || IND
+	    	// IND
+	        int mask = 0;
+	        for (int i=0; i&lt;INDLEN; i++)
+	        {
+	            mask &lt;&lt;= 1;
+	            mask |= 1;
+	        }
+	        int indHE = mask &amp; sqnHELong;
+	        console.debug(&quot;SQN_HE IND = &quot; + indHE);
+	        
+	        // SEQ
+	        long seqHE = sqnHELong &gt;&gt; INDLEN;
+	        console.debug(&quot;SQN_HE SEQ = &quot; + seqHE);
+	        
+	        // get last SQN received for that index (check if the new is bigger)
+	        byte[] sqnMSBytes = akaRes.getSQN(indHE);
+	        long sqnMSLong = AKADigest.bin2long(sqnMSBytes); 
+	        console.debug(&quot;SQN_MS hex = &quot; + MessageDigestAlgorithm.toHexString(sqnMSBytes));
+	        console.debug(&quot;SQN_MS long = &quot; + sqnMSLong);
+	        
+	        long seqMS = sqnMSLong &gt;&gt; INDLEN;
+	        console.debug(&quot;SQN_MS SEQ = &quot; + seqMS);
+	        
+	        if (seqHE &lt;= seqMS	// TS 33.102 C.2.2 
+	        		|| seqHE - seqMS &gt; delta) // TS 33.102 C.2.1
+	        {
+	        	// wrap around or freshness check failed!
+	        	console.info(&quot;SEQ wrap around or freshness check failed!&quot;);
+	        	return false;
+	        }
+	        
+        	// SQN verified, set in the array
+        	akaRes.setSQN(indHE, sqnHEBytes);
+        	
+	        return true;
+	        
 		}
     	finally {
     		console.logExit();
@@ -415,8 +539,17 @@
     }
 
 
+    public static int bin2long(byte[] b){
+        int result = 0;
+        for (int i = 0; i &lt; b.length; i++){
+                result &lt;&lt;= 8;
+                result |= (b[i] &amp; 255);
+        }
+		return result;
+	}
     
     
+    
     /**
      * class representing the result of the AKA algorithm.
      * TODO: deal with SQN (TS 33.201).
@@ -424,10 +557,13 @@
     static protected class AKARES
     {
     	private byte[] password = null;
-    	private byte[] auts = null;
+    	private String auts = null;		// base64
     	
-    	// TODO: follow TS33.102 to deal with SQN
-        private String sqn = null;
+
+    	// TS 33.102 - validate SQN 
+    	private final int SQNARRAYLENGTH = 32; 
+        private Vector&lt;byte[]&gt; sqnArray = null;
+        private int lastUsedIndex = 0;
         
         // TS 33.201 - USIM shall store original CK, IK until the next successful execution of AKA
         private byte[] IK = null;
@@ -442,7 +578,7 @@
     		this.password = pass;
     	}
     	
-    	public void setAUTS(byte[] auts) {
+    	public void setAUTS(String auts) {
     		this.auts = auts;
     	}
     	
@@ -461,7 +597,7 @@
     		return password;
     	}
     	
-    	public byte[] getAUTS() {
+    	public String getAUTS() {
     		return auts;
     	}
     	
@@ -476,21 +612,47 @@
     	}
     	
     	
-    	
-    	// TODO: follow TS33.102 to deal with SQN
     	public void initSQN()
     	{
-        	sqn = new String(&quot;dummy&quot;);
+        	sqnArray = new Vector&lt;byte[]&gt;(SQNARRAYLENGTH);
+       		sqnArray.setSize(SQNARRAYLENGTH);
         }
-    	public void incrementSQN()
+    	
+    	public void setSQN(int index, byte[] sqn)
     	{
-        	//this.sqn;
+    		if (index &lt; 0 || index &gt; SQNARRAYLENGTH)
+        		return;
+    		
+    		sqnArray.set(index % SQNARRAYLENGTH, sqn);
         }
-        public byte[] getSQN()
+    	
+        public byte[] getSQN(int index)
         {
-        	return this.sqn.getBytes();
+        	if (index &lt; 0 || index &gt; SQNARRAYLENGTH)
+        		return null;
+        	
+        	lastUsedIndex = index % SQNARRAYLENGTH;
+        	console.debug(&quot;AKA SQN array: get index &quot; + lastUsedIndex);
+        	
+        	byte[] sqn = sqnArray.get(lastUsedIndex);
+        	if (sqn == null)
+        	{
+        		sqn = new byte[SQNLEN];
+        	}
+        	
+        	return sqn; 
         }
         
+        public byte[] getLastUsedSQN()
+        {
+        	byte[] sqn = sqnArray.get(lastUsedIndex);
+        	if (sqn == null)
+        	{
+        		sqn = new byte[SQNLEN];
+        	}
+        	
+        	return sqn; 
+        }
 
     	
     	

Deleted: trunk/ims-communicator/src/net/java/sip/communicator/sip/security/Base64.java
===================================================================
--- trunk/ims-communicator/src/net/java/sip/communicator/sip/security/Base64.java	2007-12-05 16:59:53 UTC (rev 88)
+++ trunk/ims-communicator/src/net/java/sip/communicator/sip/security/Base64.java	2007-12-11 17:46:19 UTC (rev 89)
@@ -1,123 +0,0 @@
-package net.java.sip.communicator.sip.security;
-
-
-/********************************************************************************************************************
-* $Id: Base64.java,v 1.2 2007/12/05 09:56:04 miguel Exp $
-*
-* Copyright (c) 2000-2002 by Russell Gold
-*
-* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated 
-* documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation 
-* the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
-* to permit persons to whom the Software is furnished to do so, subject to the following conditions:
-*
-* The above copyright notice and this permission notice shall be included in all copies or substantial portions 
-* of the Software.
-*
-* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
-* THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
-* CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-* DEALINGS IN THE SOFTWARE.
-*
-*******************************************************************************************************************/
-
-/**
- * A utility class to convert to and from base 64 encoding.
- * <A HREF="http://www.koders.com/java/fid2B76F86B8F8FF984EFE3C04AC6DE198E40D8EF41.aspx">http://www.koders.com/java/fid2B76F86B8F8FF984EFE3C04AC6DE198E40D8EF41.aspx</A>
- * @author &lt;a href=&quot;mailto:<A HREF="https://lists.berlios.de/mailman/listinfo/imscommunicator-dev">russgold at httpunit.org</A>&quot;&gt;Russell Gold&lt;/a&gt;
- **/
-public class Base64 {
-
-    final static String encodingChar = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
-
-
-    /**
-     * Returns the base 64 encoded equivalent of a supplied string.
-     * @param source the string to encode
-     */
-    public static String encode( String source ) {
-        char[] sourceBytes = getPaddedBytes( source );
-        int numGroups = (sourceBytes.length + 2) / 3;
-        char[] targetBytes = new char[4];
-        char[] target = new char[ 4 * numGroups ];
-
-        for (int group = 0; group &lt; numGroups; group++) {
-            convert3To4( sourceBytes, group*3, targetBytes );
-            for (int i = 0; i &lt; targetBytes.length; i++) {
-                target[ i + 4*group ] = encodingChar.charAt( targetBytes[i] );
-            }
-        }
-
-        int numPadBytes = sourceBytes.length - source.length();
-
-        for (int i = target.length-numPadBytes; i &lt; target.length; i++) target[i] = '=';
-        return new String( target );
-    }
-
-
-    private static char[] getPaddedBytes( String source ) {
-        char[] converted = source.toCharArray();
-        int requiredLength = 3 * ((converted.length+2) /3);
-        char[] result = new char[ requiredLength ];
-        System.arraycopy( converted, 0, result, 0, converted.length );
-        return result;
-    }
-
-
-    private static void convert3To4( char[] source, int sourceIndex, char[] target ) {
-        target[0] = (char) ( source[ sourceIndex ] &gt;&gt;&gt; 2);
-        target[1] = (char) (((source[ sourceIndex   ] &amp; 0x03) &lt;&lt; 4) | (source[ sourceIndex+1 ] &gt;&gt;&gt; 4));
-        target[2] = (char) (((source[ sourceIndex+1 ] &amp; 0x0f) &lt;&lt; 2) | (source[ sourceIndex+2 ] &gt;&gt;&gt; 6));
-        target[3] = (char) (  source[ sourceIndex+2 ] &amp; 0x3f);
-    }
-
-
-    /**
-     * Returns the plaintext equivalent of a base 64-encoded string.
-     * @param source a base 64 string (which must have a multiple of 4 characters)
-     */
-    public static String decode( String source ) {
-        if (source.length()%4 != 0) throw new RuntimeException( &quot;valid Base64 codes have a multiple of 4 characters&quot; );
-        int numGroups = source.length() / 4;
-        int numExtraBytes = source.endsWith( &quot;==&quot; ) ? 2 : (source.endsWith( &quot;=&quot; ) ? 1 : 0);
-        byte[] targetBytes = new byte[ 3*numGroups ];
-        byte[] sourceBytes = new byte[4];
-        for (int group = 0; group &lt; numGroups; group++) {
-            for (int i = 0; i &lt; sourceBytes.length; i++) {
-                sourceBytes[i] = (byte) Math.max( 0, encodingChar.indexOf( source.charAt( 4*group+i ) ) );
-            }
-            convert4To3( sourceBytes, targetBytes, group*3 );
-        }
-        return new String( targetBytes, 0, targetBytes.length - numExtraBytes );
-    }
-
-
-    // issued by Miguel Freitas //
-    /**
-     * 
-     */
-    public static byte[] decodeToByte( String source ) {
-        if (source.length()%4 != 0) throw new RuntimeException( &quot;valid Base64 codes have a multiple of 4 characters&quot; );
-        int numGroups = source.length() / 4;
-        int numExtraBytes = source.endsWith( &quot;==&quot; ) ? 2 : (source.endsWith( &quot;=&quot; ) ? 1 : 0);
-        byte[] targetBytes = new byte[ 3*numGroups ];
-        byte[] sourceBytes = new byte[4];
-        for (int group = 0; group &lt; numGroups; group++) {
-            for (int i = 0; i &lt; sourceBytes.length; i++) {
-                sourceBytes[i] = (byte) Math.max( 0, encodingChar.indexOf( source.charAt( 4*group+i ) ) );
-            }
-            convert4To3( sourceBytes, targetBytes, group*3 );
-        }
-        return targetBytes;
-    }
-    // end // 
-    
-    
-    private static void convert4To3( byte[] source, byte[] target, int targetIndex ) {
-        target[ targetIndex  ]  = (byte) (( source[0] &lt;&lt; 2) | (source[1] &gt;&gt;&gt; 4));
-        target[ targetIndex+1 ] = (byte) (((source[1] &amp; 0x0f) &lt;&lt; 4) | (source[2] &gt;&gt;&gt; 2));
-        target[ targetIndex+2 ] = (byte) (((source[2] &amp; 0x03) &lt;&lt; 6) | (source[3]));
-    }
-
-}

Added: trunk/ims-communicator/src/net/java/sip/communicator/sip/security/Base64Coder.java
===================================================================
--- trunk/ims-communicator/src/net/java/sip/communicator/sip/security/Base64Coder.java	2007-12-05 16:59:53 UTC (rev 88)
+++ trunk/ims-communicator/src/net/java/sip/communicator/sip/security/Base64Coder.java	2007-12-11 17:46:19 UTC (rev 89)
@@ -0,0 +1,1809 @@
+package net.java.sip.communicator.sip.security;
+
+/**
+ * &lt;p&gt;Encodes and decodes to and from Base64Coder notation.&lt;/p&gt;
+ * &lt;p&gt;Homepage: &lt;a href=&quot;<A HREF="http://iharder.net/Base64Coder">http://iharder.net/Base64Coder</A>&quot;&gt;<A HREF="http://iharder.net/Base64Coder&lt;/a">http://iharder.net/Base64Coder&lt;/a</A>&gt;.&lt;/p&gt;
+ *
+ * &lt;p&gt;The &lt;tt&gt;options&lt;/tt&gt; parameter, which appears in a few places, is used to pass 
+ * several pieces of information to the encoder. In the &quot;higher level&quot; methods such as 
+ * encodeBytes( bytes, options ) the options parameter can be used to indicate such 
+ * things as first gzipping the bytes before encoding them, not inserting linefeeds 
+ * (though that breaks strict Base64Coder compatibility), and encoding using the URL-safe 
+ * and Ordered dialects.&lt;/p&gt;
+ *
+ * &lt;p&gt;The constants defined in Base64Coder can be OR-ed together to combine options, so you 
+ * might make a call like this:&lt;/p&gt;
+ *
+ * &lt;code&gt;String encoded = Base64Coder.encodeBytes( mybytes, Base64Coder.GZIP | Base64Coder.DONT_BREAK_LINES );&lt;/code&gt;
+ *
+ * &lt;p&gt;to compress the data before encoding it and then making the output have no newline characters.&lt;/p&gt;
+ *
+ *
+ * &lt;p&gt;
+ * Change Log:
+ * &lt;/p&gt;
+ * &lt;ul&gt;
+ *  &lt;li&gt;v2.2.2 - Fixed encodeFileToFile and decodeFileToFile to use the
+ *   Base64Coder.InputStream class to encode and decode on the fly which uses
+ *   less memory than encoding/decoding an entire file into memory before writing.&lt;/li&gt;
+ *  &lt;li&gt;v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug
+ *   when using very small files (~&lt; 40 bytes).&lt;/li&gt;
+ *  &lt;li&gt;v2.2 - Added some helper methods for encoding/decoding directly from
+ *   one file to the next. Also added a main() method to support command line
+ *   encoding/decoding from one file to the next. Also added these Base64Coder dialects:
+ *   &lt;ol&gt;
+ *   &lt;li&gt;The default is RFC3548 format.&lt;/li&gt;
+ *   &lt;li&gt;Calling Base64Coder.setFormat(Base64Coder.Base64Coder_FORMAT.URLSAFE_FORMAT) generates
+ *   URL and file name friendly format as described in Section 4 of RFC3548.
+ *   <A HREF="http://www.faqs.org/rfcs/rfc3548.html&lt;/li">http://www.faqs.org/rfcs/rfc3548.html&lt;/li</A>&gt;
+ *   &lt;li&gt;Calling Base64Coder.setFormat(Base64Coder.Base64Coder_FORMAT.ORDERED_FORMAT) generates
+ *   URL and file name friendly format that preserves lexical ordering as described
+ *   in <A HREF="http://www.faqs.org/qa/rfcc-1940.html&lt;/li">http://www.faqs.org/qa/rfcc-1940.html&lt;/li</A>&gt;
+ *   &lt;/ol&gt;
+ *   Special thanks to Jim Kellerman at &lt;a href=&quot;<A HREF="http://www.powerset.com/">http://www.powerset.com/</A>&quot;&gt;<A HREF="http://www.powerset.com/&lt;/a">http://www.powerset.com/&lt;/a</A>&gt;
+ *   for contributing the new Base64Coder dialects.
+ *  &lt;/li&gt;
+ * 
+ *  &lt;li&gt;v2.1 - Cleaned up javadoc comments and unused variables and methods. Added
+ *   some convenience methods for reading and writing to and from files.&lt;/li&gt;
+ *  &lt;li&gt;v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems
+ *   with other encodings (like EBCDIC).&lt;/li&gt;
+ *  &lt;li&gt;v2.0.1 - Fixed an error when decoding a single byte, that is, when the
+ *   encoded data was a single byte.&lt;/li&gt;
+ *  &lt;li&gt;v2.0 - I got rid of methods that used booleans to set options. 
+ *   Now everything is more consolidated and cleaner. The code now detects
+ *   when data that's being decoded is gzip-compressed and will decompress it
+ *   automatically. Generally things are cleaner. You'll probably have to
+ *   change some method calls that you were making to support the new
+ *   options format (&lt;tt&gt;int&lt;/tt&gt;s that you &quot;OR&quot; together).&lt;/li&gt;
+ *  &lt;li&gt;v1.5.1 - Fixed bug when decompressing and decoding to a             
+ *   byte[] using &lt;tt&gt;decode( String s, boolean gzipCompressed )&lt;/tt&gt;.      
+ *   Added the ability to &quot;suspend&quot; encoding in the Output Stream so        
+ *   you can turn on and off the encoding if you need to embed Base64Coder       
+ *   data in an otherwise &quot;normal&quot; stream (like an XML file).&lt;/li&gt;  
+ *  &lt;li&gt;v1.5 - Output stream pases on flush() command but doesn't do anything itself.
+ *      This helps when using GZIP streams.
+ *      Added the ability to GZip-compress objects before encoding them.&lt;/li&gt;
+ *  &lt;li&gt;v1.4 - Added helper methods to read/write files.&lt;/li&gt;
+ *  &lt;li&gt;v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.&lt;/li&gt;
+ *  &lt;li&gt;v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream
+ *      where last buffer being read, if not completely full, was not returned.&lt;/li&gt;
+ *  &lt;li&gt;v1.3.4 - Fixed when &quot;improperly padded stream&quot; error was thrown at the wrong time.&lt;/li&gt;
+ *  &lt;li&gt;v1.3.3 - Fixed I/O streams which were totally messed up.&lt;/li&gt;
+ * &lt;/ul&gt;
+ *
+ * &lt;p&gt;
+ * I am placing this code in the Public Domain. Do with it as you will.
+ * This software comes with no guarantees or warranties but with
+ * plenty of well-wishing instead!
+ * Please visit &lt;a href=&quot;<A HREF="http://iharder.net/Base64Coder">http://iharder.net/Base64Coder</A>&quot;&gt;<A HREF="http://iharder.net/Base64Coder&lt;/a">http://iharder.net/Base64Coder&lt;/a</A>&gt;
+ * periodically to check for updates or to contribute improvements.
+ * &lt;/p&gt;
+ *
+ * @author Robert Harder
+ * @author <A HREF="https://lists.berlios.de/mailman/listinfo/imscommunicator-dev">rob at iharder.net</A>
+ * @version 2.2.2
+ */
+public class Base64Coder
+{
+    
+/* ********  P U B L I C   F I E L D S  ******** */   
+    
+    
+    /** No options specified. Value is zero. */
+    public final static int NO_OPTIONS = 0;
+    
+    /** Specify encoding. */
+    public final static int ENCODE = 1;
+    
+    
+    /** Specify decoding. */
+    public final static int DECODE = 0;
+    
+    
+    /** Specify that data should be gzip-compressed. */
+    public final static int GZIP = 2;
+    
+    
+    /** Don't break lines when encoding (violates strict Base64Coder specification) */
+    public final static int DONT_BREAK_LINES = 8;
+	
+	/** 
+	 * Encode using Base64Coder-like encoding that is URL- and Filename-safe as described
+	 * in Section 4 of RFC3548: 
+	 * &lt;a href=&quot;<A HREF="http://www.faqs.org/rfcs/rfc3548.html">http://www.faqs.org/rfcs/rfc3548.html</A>&quot;&gt;<A HREF="http://www.faqs.org/rfcs/rfc3548.html&lt;/a">http://www.faqs.org/rfcs/rfc3548.html&lt;/a</A>&gt;.
+	 * It is important to note that data encoded this way is &lt;em&gt;not&lt;/em&gt; officially valid Base64Coder, 
+	 * or at the very least should not be called Base64Coder without also specifying that is
+	 * was encoded using the URL- and Filename-safe dialect.
+	 */
+	 public final static int URL_SAFE = 16;
+	 
+	 
+	 /**
+	  * Encode using the special &quot;ordered&quot; dialect of Base64Coder described here:
+	  * &lt;a href=&quot;<A HREF="http://www.faqs.org/qa/rfcc-1940.html">http://www.faqs.org/qa/rfcc-1940.html</A>&quot;&gt;<A HREF="http://www.faqs.org/qa/rfcc-1940.html&lt;/a">http://www.faqs.org/qa/rfcc-1940.html&lt;/a</A>&gt;.
+	  */
+	 public final static int ORDERED = 32;
+    
+    
+/* ********  P R I V A T E   F I E L D S  ******** */  
+    
+    
+    /** Maximum line length (76) of Base64Coder output. */
+    private final static int MAX_LINE_LENGTH = 76;
+    
+    
+    /** The equals sign (=) as a byte. */
+    private final static byte EQUALS_SIGN = (byte)'=';
+    
+    
+    /** The new line character (\n) as a byte. */
+    private final static byte NEW_LINE = (byte)'\n';
+    
+    
+    /** Preferred encoding. */
+    private final static String PREFERRED_ENCODING = &quot;UTF-8&quot;;
+    
+	
+    // I think I end up not using the BAD_ENCODING indicator.
+    //private final static byte BAD_ENCODING    = -9; // Indicates error in encoding
+    private final static byte WHITE_SPACE_ENC = -5; // Indicates white space in encoding
+    private final static byte EQUALS_SIGN_ENC = -1; // Indicates equals sign in encoding
+	
+	
+/* ********  S T A N D A R D   B A S E 6 4   A L P H A B E T  ******** */	
+    
+    /** The 64 valid Base64Coder values. */
+    //private final static byte[] ALPHABET;
+	/* Host platform me be something funny like EBCDIC, so we hardcode these values. */
+	private final static byte[] _STANDARD_ALPHABET =
+    {
+        (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',
+        (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',
+        (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', 
+        (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',
+        (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',
+        (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',
+        (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', 
+        (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',
+        (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', 
+        (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'+', (byte)'/'
+    };
+	
+    
+    /** 
+     * Translates a Base64Coder value to either its 6-bit reconstruction value
+     * or a negative number indicating some other meaning.
+     **/
+    private final static byte[] _STANDARD_DECODABET =
+    {   
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8
+        -5,-5,                                      // Whitespace: Tab and Linefeed
+        -9,-9,                                      // Decimal 11 - 12
+        -5,                                         // Whitespace: Carriage Return
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26
+        -9,-9,-9,-9,-9,                             // Decimal 27 - 31
+        -5,                                         // Whitespace: Space
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42
+        62,                                         // Plus sign at decimal 43
+        -9,-9,-9,                                   // Decimal 44 - 46
+        63,                                         // Slash at decimal 47
+        52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine
+        -9,-9,-9,                                   // Decimal 58 - 60
+        -1,                                         // Equals sign at decimal 61
+        -9,-9,-9,                                      // Decimal 62 - 64
+        0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'
+        14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'
+        -9,-9,-9,-9,-9,-9,                          // Decimal 91 - 96
+        26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'
+        39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'
+        -9,-9,-9,-9                                 // Decimal 123 - 126
+        /*,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 127 - 139
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 */
+    };
+	
+	
+/* ********  U R L   S A F E   B A S E 6 4   A L P H A B E T  ******** */
+	
+	/**
+	 * Used in the URL- and Filename-safe dialect described in Section 4 of RFC3548: 
+	 * &lt;a href=&quot;<A HREF="http://www.faqs.org/rfcs/rfc3548.html">http://www.faqs.org/rfcs/rfc3548.html</A>&quot;&gt;<A HREF="http://www.faqs.org/rfcs/rfc3548.html&lt;/a">http://www.faqs.org/rfcs/rfc3548.html&lt;/a</A>&gt;.
+	 * Notice that the last two bytes become &quot;hyphen&quot; and &quot;underscore&quot; instead of &quot;plus&quot; and &quot;slash.&quot;
+	 */
+    private final static byte[] _URL_SAFE_ALPHABET =
+    {
+      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',
+      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',
+      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', 
+      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',
+      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',
+      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',
+      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', 
+      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',
+      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', 
+      (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'-', (byte)'_'
+    };
+	
+	/**
+	 * Used in decoding URL- and Filename-safe dialects of Base64Coder.
+	 */
+    private final static byte[] _URL_SAFE_DECODABET =
+    {   
+      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8
+      -5,-5,                                      // Whitespace: Tab and Linefeed
+      -9,-9,                                      // Decimal 11 - 12
+      -5,                                         // Whitespace: Carriage Return
+      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26
+      -9,-9,-9,-9,-9,                             // Decimal 27 - 31
+      -5,                                         // Whitespace: Space
+      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42
+      -9,                                         // Plus sign at decimal 43
+      -9,                                         // Decimal 44
+      62,                                         // Minus sign at decimal 45
+      -9,                                         // Decimal 46
+      -9,                                         // Slash at decimal 47
+      52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine
+      -9,-9,-9,                                   // Decimal 58 - 60
+      -1,                                         // Equals sign at decimal 61
+      -9,-9,-9,                                   // Decimal 62 - 64
+      0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'
+      14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'
+      -9,-9,-9,-9,                                // Decimal 91 - 94
+      63,                                         // Underscore at decimal 95
+      -9,                                         // Decimal 96
+      26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'
+      39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'
+      -9,-9,-9,-9                                 // Decimal 123 - 126
+      /*,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 127 - 139
+      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152
+      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165
+      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178
+      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191
+      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204
+      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217
+      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230
+      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243
+      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 */
+    };
+
+
+
+/* ********  O R D E R E D   B A S E 6 4   A L P H A B E T  ******** */
+
+	/**
+	 * I don't get the point of this technique, but it is described here:
+	 * &lt;a href=&quot;<A HREF="http://www.faqs.org/qa/rfcc-1940.html">http://www.faqs.org/qa/rfcc-1940.html</A>&quot;&gt;<A HREF="http://www.faqs.org/qa/rfcc-1940.html&lt;/a">http://www.faqs.org/qa/rfcc-1940.html&lt;/a</A>&gt;.
+	 */
+    private final static byte[] _ORDERED_ALPHABET =
+    {
+      (byte)'-',
+      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4',
+      (byte)'5', (byte)'6', (byte)'7', (byte)'8', (byte)'9',
+      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',
+      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',
+      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U',
+      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',
+      (byte)'_',
+      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',
+      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',
+      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u',
+      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z'
+    };
+	
+	/**
+	 * Used in decoding the &quot;ordered&quot; dialect of Base64Coder.
+	 */
+    private final static byte[] _ORDERED_DECODABET =
+    {   
+      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8
+      -5,-5,                                      // Whitespace: Tab and Linefeed
+      -9,-9,                                      // Decimal 11 - 12
+      -5,                                         // Whitespace: Carriage Return
+      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26
+      -9,-9,-9,-9,-9,                             // Decimal 27 - 31
+      -5,                                         // Whitespace: Space
+      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42
+      -9,                                         // Plus sign at decimal 43
+      -9,                                         // Decimal 44
+      0,                                          // Minus sign at decimal 45
+      -9,                                         // Decimal 46
+      -9,                                         // Slash at decimal 47
+      1,2,3,4,5,6,7,8,9,10,                       // Numbers zero through nine
+      -9,-9,-9,                                   // Decimal 58 - 60
+      -1,                                         // Equals sign at decimal 61
+      -9,-9,-9,                                   // Decimal 62 - 64
+      11,12,13,14,15,16,17,18,19,20,21,22,23,     // Letters 'A' through 'M'
+      24,25,26,27,28,29,30,31,32,33,34,35,36,     // Letters 'N' through 'Z'
+      -9,-9,-9,-9,                                // Decimal 91 - 94
+      37,                                         // Underscore at decimal 95
+      -9,                                         // Decimal 96
+      38,39,40,41,42,43,44,45,46,47,48,49,50,     // Letters 'a' through 'm'
+      51,52,53,54,55,56,57,58,59,60,61,62,63,     // Letters 'n' through 'z'
+      -9,-9,-9,-9                                 // Decimal 123 - 126
+      /*,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 127 - 139
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 */
+    };
+
+	
+/* ********  D E T E R M I N E   W H I C H   A L H A B E T  ******** */
+
+
+	/**
+	 * Returns one of the _SOMETHING_ALPHABET byte arrays depending on
+	 * the options specified.
+	 * It's possible, though silly, to specify ORDERED and URLSAFE
+	 * in which case one of them will be picked, though there is
+	 * no guarantee as to which one will be picked.
+	 */
+	private final static byte[] getAlphabet( int options )
+	{
+		if( (options &amp; URL_SAFE) == URL_SAFE ) return _URL_SAFE_ALPHABET;
+		else if( (options &amp; ORDERED) == ORDERED ) return _ORDERED_ALPHABET;
+		else return _STANDARD_ALPHABET;
+		
+	}	// end getAlphabet
+	
+	
+	/**
+	 * Returns one of the _SOMETHING_DECODABET byte arrays depending on
+	 * the options specified.
+	 * It's possible, though silly, to specify ORDERED and URL_SAFE
+	 * in which case one of them will be picked, though there is
+	 * no guarantee as to which one will be picked.
+	 */
+	private final static byte[] getDecodabet( int options )
+	{
+		if( (options &amp; URL_SAFE) == URL_SAFE ) return _URL_SAFE_DECODABET;
+		else if( (options &amp; ORDERED) == ORDERED ) return _ORDERED_DECODABET;
+		else return _STANDARD_DECODABET;
+		
+	}	// end getAlphabet
+        
+
+    
+    /** Defeats instantiation. */
+    private Base64Coder(){}
+    
+
+    /**
+     * Encodes or decodes two files from the command line;
+     * &lt;strong&gt;feel free to delete this method (in fact you probably should)
+     * if you're embedding this code into a larger program.&lt;/strong&gt;
+     */
+    public final static void main( String[] args )
+    {
+        if( args.length &lt; 3 ){
+            usage(&quot;Not enough arguments.&quot;);
+        }   // end if: args.length &lt; 3
+        else {
+            String flag = args[0];
+            String infile = args[1];
+            String outfile = args[2];
+            if( flag.equals( &quot;-e&quot; ) ){
+                Base64Coder.encodeFileToFile( infile, outfile );
+            }   // end if: encode
+            else if( flag.equals( &quot;-d&quot; ) ) {
+                Base64Coder.decodeFileToFile( infile, outfile );
+            }   // end else if: decode    
+            else {
+                usage( &quot;Unknown flag: &quot; + flag );
+            }   // end else    
+        }   // end else
+    }   // end main
+
+    /**
+     * Prints command line usage.
+     *
+     * @param msg A message to include with usage info.
+     */
+    private final static void usage( String msg )
+    {
+        System.err.println( msg );
+        System.err.println( &quot;Usage: java Base64Coder -e|-d inputfile outputfile&quot; );
+    }   // end usage
+    
+    
+/* ********  E N C O D I N G   M E T H O D S  ******** */    
+    
+    
+    /**
+     * Encodes up to the first three bytes of array &lt;var&gt;threeBytes&lt;/var&gt;
+     * and returns a four-byte array in Base64Coder notation.
+     * The actual number of significant bytes in your array is
+     * given by &lt;var&gt;numSigBytes&lt;/var&gt;.
+     * The array &lt;var&gt;threeBytes&lt;/var&gt; needs only be as big as
+     * &lt;var&gt;numSigBytes&lt;/var&gt;.
+     * Code can reuse a byte array by passing a four-byte array as &lt;var&gt;b4&lt;/var&gt;.
+     *
+     * @param b4 A reusable byte array to reduce array instantiation
+     * @param threeBytes the array to convert
+     * @param numSigBytes the number of significant bytes in your array
+     * @return four byte array in Base64Coder notation.
+     * @since 1.5.1
+     */
+    private static byte[] encode3to4( byte[] b4, byte[] threeBytes, int numSigBytes, int options )
+    {
+        encode3to4( threeBytes, 0, numSigBytes, b4, 0, options );
+        return b4;
+    }   // end encode3to4
+
+    
+    /**
+     * &lt;p&gt;Encodes up to three bytes of the array &lt;var&gt;source&lt;/var&gt;
+     * and writes the resulting four Base64Coder bytes to &lt;var&gt;destination&lt;/var&gt;.
+     * The source and destination arrays can be manipulated
+     * anywhere along their length by specifying 
+     * &lt;var&gt;srcOffset&lt;/var&gt; and &lt;var&gt;destOffset&lt;/var&gt;.
+     * This method does not check to make sure your arrays
+     * are large enough to accomodate &lt;var&gt;srcOffset&lt;/var&gt; + 3 for
+     * the &lt;var&gt;source&lt;/var&gt; array or &lt;var&gt;destOffset&lt;/var&gt; + 4 for
+     * the &lt;var&gt;destination&lt;/var&gt; array.
+     * The actual number of significant bytes in your array is
+     * given by &lt;var&gt;numSigBytes&lt;/var&gt;.&lt;/p&gt;
+	 * &lt;p&gt;This is the lowest level of the encoding methods with
+	 * all possible parameters.&lt;/p&gt;
+     *
+     * @param source the array to convert
+     * @param srcOffset the index where conversion begins
+     * @param numSigBytes the number of significant bytes in your array
+     * @param destination the array to hold the conversion
+     * @param destOffset the index where output will be put
+     * @return the &lt;var&gt;destination&lt;/var&gt; array
+     * @since 1.3
+     */
+    private static byte[] encode3to4( 
+     byte[] source, int srcOffset, int numSigBytes,
+     byte[] destination, int destOffset, int options )
+    {
+		byte[] ALPHABET = getAlphabet( options ); 
+	
+        //           1         2         3  
+        // 01234567890123456789012345678901 Bit position
+        // --------000000001111111122222222 Array position from threeBytes
+        // --------|    ||    ||    ||    | Six bit groups to index ALPHABET
+        //          &gt;&gt;18  &gt;&gt;12  &gt;&gt; 6  &gt;&gt; 0  Right shift necessary
+        //                0x3f  0x3f  0x3f  Additional AND
+        
+        // Create buffer with zero-padding if there are only one or two
+        // significant bytes passed in the array.
+        // We have to shift left 24 in order to flush out the 1's that appear
+        // when Java treats a value as negative that is cast from a byte to an int.
+        int inBuff =   ( numSigBytes &gt; 0 ? ((source[ srcOffset     ] &lt;&lt; 24) &gt;&gt;&gt;  8) : 0 )
+                     | ( numSigBytes &gt; 1 ? ((source[ srcOffset + 1 ] &lt;&lt; 24) &gt;&gt;&gt; 16) : 0 )
+                     | ( numSigBytes &gt; 2 ? ((source[ srcOffset + 2 ] &lt;&lt; 24) &gt;&gt;&gt; 24) : 0 );
+
+        switch( numSigBytes )
+        {
+            case 3:
+                destination[ destOffset     ] = ALPHABET[ (inBuff &gt;&gt;&gt; 18)        ];
+                destination[ destOffset + 1 ] = ALPHABET[ (inBuff &gt;&gt;&gt; 12) &amp; 0x3f ];
+                destination[ destOffset + 2 ] = ALPHABET[ (inBuff &gt;&gt;&gt;  6) &amp; 0x3f ];
+                destination[ destOffset + 3 ] = ALPHABET[ (inBuff       ) &amp; 0x3f ];
+                return destination;
+                
+            case 2:
+                destination[ destOffset     ] = ALPHABET[ (inBuff &gt;&gt;&gt; 18)        ];
+                destination[ destOffset + 1 ] = ALPHABET[ (inBuff &gt;&gt;&gt; 12) &amp; 0x3f ];
+                destination[ destOffset + 2 ] = ALPHABET[ (inBuff &gt;&gt;&gt;  6) &amp; 0x3f ];
+                destination[ destOffset + 3 ] = EQUALS_SIGN;
+                return destination;
+                
+            case 1:
+                destination[ destOffset     ] = ALPHABET[ (inBuff &gt;&gt;&gt; 18)        ];
+                destination[ destOffset + 1 ] = ALPHABET[ (inBuff &gt;&gt;&gt; 12) &amp; 0x3f ];
+                destination[ destOffset + 2 ] = EQUALS_SIGN;
+                destination[ destOffset + 3 ] = EQUALS_SIGN;
+                return destination;
+                
+            default:
+                return destination;
+        }   // end switch
+    }   // end encode3to4
+    
+    
+    
+    /**
+     * Serializes an object and returns the Base64Coder-encoded
+     * version of that serialized object. If the object
+     * cannot be serialized or there is another error,
+     * the method will return &lt;tt&gt;null&lt;/tt&gt;.
+     * The object is not GZip-compressed before being encoded.
+     *
+     * @param serializableObject The object to encode
+     * @return The Base64Coder-encoded object
+     * @since 1.4
+     */
+    public static String encodeObject( java.io.Serializable serializableObject )
+    {
+        return encodeObject( serializableObject, NO_OPTIONS );
+    }   // end encodeObject
+    
+
+
+    /**
+     * Serializes an object and returns the Base64Coder-encoded
+     * version of that serialized object. If the object
+     * cannot be serialized or there is another error,
+     * the method will return &lt;tt&gt;null&lt;/tt&gt;.
+     * &lt;p&gt;
+     * Valid options:&lt;pre&gt;
+     *   GZIP: gzip-compresses object before encoding it.
+     *   DONT_BREAK_LINES: don't break lines at 76 characters
+     *     &lt;i&gt;Note: Technically, this makes your encoding non-compliant.&lt;/i&gt;
+     * &lt;/pre&gt;
+     * &lt;p&gt;
+     * Example: &lt;code&gt;encodeObject( myObj, Base64Coder.GZIP )&lt;/code&gt; or
+     * &lt;p&gt;
+     * Example: &lt;code&gt;encodeObject( myObj, Base64Coder.GZIP | Base64Coder.DONT_BREAK_LINES )&lt;/code&gt;
+     *
+     * @param serializableObject The object to encode
+     * @param options Specified options
+     * @return The Base64Coder-encoded object
+     * @see Base64Coder#GZIP
+     * @see Base64Coder#DONT_BREAK_LINES
+     * @since 2.0
+     */
+    public static String encodeObject( java.io.Serializable serializableObject, int options )
+    {
+        // Streams
+        java.io.ByteArrayOutputStream  baos  = null; 
+        java.io.OutputStream           b64os = null; 
+        java.io.ObjectOutputStream     oos   = null; 
+        java.util.zip.GZIPOutputStream gzos  = null;
+        
+        // Isolate options
+        int gzip           = (options &amp; GZIP);
+        int dontBreakLines = (options &amp; DONT_BREAK_LINES);
+        
+        try
+        {
+            // ObjectOutputStream -&gt; (GZIP) -&gt; Base64Coder -&gt; ByteArrayOutputStream
+            baos  = new java.io.ByteArrayOutputStream();
+            b64os = new Base64Coder.OutputStream( baos, ENCODE | options );
+    
+            // GZip?
+            if( gzip == GZIP )
+            {
+                gzos = new java.util.zip.GZIPOutputStream( b64os );
+                oos  = new java.io.ObjectOutputStream( gzos );
+            }   // end if: gzip
+            else
+                oos   = new java.io.ObjectOutputStream( b64os );
+            
+            oos.writeObject( serializableObject );
+        }   // end try
+        catch( java.io.IOException e )
+        {
+            e.printStackTrace();
+            return null;
+        }   // end catch
+        finally
+        {
+            try{ oos.close();   } catch( Exception e ){}
+            try{ gzos.close();  } catch( Exception e ){}
+            try{ b64os.close(); } catch( Exception e ){}
+            try{ baos.close();  } catch( Exception e ){}
+        }   // end finally
+        
+        // Return value according to relevant encoding.
+        try 
+        {
+            return new String( baos.toByteArray(), PREFERRED_ENCODING );
+        }   // end try
+        catch (java.io.UnsupportedEncodingException uue)
+        {
+            return new String( baos.toByteArray() );
+        }   // end catch
+        
+    }   // end encode
+    
+    
+
+    /**
+     * Encodes a byte array into Base64Coder notation.
+     * Does not GZip-compress data.
+     *
+     * @param source The data to convert
+     * @since 1.4
+     */
+    public static String encodeBytes( byte[] source )
+    {
+        return encodeBytes( source, 0, source.length, NO_OPTIONS );
+    }   // end encodeBytes
+    
+
+
+    /**
+     * Encodes a byte array into Base64Coder notation.
+     * &lt;p&gt;
+     * Valid options:&lt;pre&gt;
+     *   GZIP: gzip-compresses object before encoding it.
+     *   DONT_BREAK_LINES: don't break lines at 76 characters
+     *     &lt;i&gt;Note: Technically, this makes your encoding non-compliant.&lt;/i&gt;
+     * &lt;/pre&gt;
+     * &lt;p&gt;
+     * Example: &lt;code&gt;encodeBytes( myData, Base64Coder.GZIP )&lt;/code&gt; or
+     * &lt;p&gt;
+     * Example: &lt;code&gt;encodeBytes( myData, Base64Coder.GZIP | Base64Coder.DONT_BREAK_LINES )&lt;/code&gt;
+     *
+     *
+     * @param source The data to convert
+     * @param options Specified options
+     * @see Base64Coder#GZIP
+     * @see Base64Coder#DONT_BREAK_LINES
+     * @since 2.0
+     */
+    public static String encodeBytes( byte[] source, int options )
+    {   
+        return encodeBytes( source, 0, source.length, options );
+    }   // end encodeBytes
+    
+    
+    /**
+     * Encodes a byte array into Base64Coder notation.
+     * Does not GZip-compress data.
+     *
+     * @param source The data to convert
+     * @param off Offset in array where conversion should begin
+     * @param len Length of data to convert
+     * @since 1.4
+     */
+    public static String encodeBytes( byte[] source, int off, int len )
+    {
+        return encodeBytes( source, off, len, NO_OPTIONS );
+    }   // end encodeBytes
+    
+    
+
+    /**
+     * Encodes a byte array into Base64Coder notation.
+     * &lt;p&gt;
+     * Valid options:&lt;pre&gt;
+     *   GZIP: gzip-compresses object before encoding it.
+     *   DONT_BREAK_LINES: don't break lines at 76 characters
+     *     &lt;i&gt;Note: Technically, this makes your encoding non-compliant.&lt;/i&gt;
+     * &lt;/pre&gt;
+     * &lt;p&gt;
+     * Example: &lt;code&gt;encodeBytes( myData, Base64Coder.GZIP )&lt;/code&gt; or
+     * &lt;p&gt;
+     * Example: &lt;code&gt;encodeBytes( myData, Base64Coder.GZIP | Base64Coder.DONT_BREAK_LINES )&lt;/code&gt;
+     *
+     *
+     * @param source The data to convert
+     * @param off Offset in array where conversion should begin
+     * @param len Length of data to convert
+     * @param options Specified options
+	 * @param options alphabet type is pulled from this (standard, url-safe, ordered)
+     * @see Base64Coder#GZIP
+     * @see Base64Coder#DONT_BREAK_LINES
+     * @since 2.0
+     */
+    public static String encodeBytes( byte[] source, int off, int len, int options )
+    {
+        // Isolate options
+        int dontBreakLines = ( options &amp; DONT_BREAK_LINES );
+        int gzip           = ( options &amp; GZIP   );
+        
+        // Compress?
+        if( gzip == GZIP )
+        {
+            java.io.ByteArrayOutputStream  baos  = null;
+            java.util.zip.GZIPOutputStream gzos  = null;
+            Base64Coder.OutputStream            b64os = null;
+            
+    
+            try
+            {
+                // GZip -&gt; Base64Coder -&gt; ByteArray
+                baos = new java.io.ByteArrayOutputStream();
+                b64os = new Base64Coder.OutputStream( baos, ENCODE | options );
+                gzos  = new java.util.zip.GZIPOutputStream( b64os ); 
+            
+                gzos.write( source, off, len );
+                gzos.close();
+            }   // end try
+            catch( java.io.IOException e )
+            {
+                e.printStackTrace();
+                return null;
+            }   // end catch
+            finally
+            {
+                try{ gzos.close();  } catch( Exception e ){}
+                try{ b64os.close(); } catch( Exception e ){}
+                try{ baos.close();  } catch( Exception e ){}
+            }   // end finally
+
+            // Return value according to relevant encoding.
+            try
+            {
+                return new String( baos.toByteArray(), PREFERRED_ENCODING );
+            }   // end try
+            catch (java.io.UnsupportedEncodingException uue)
+            {
+                return new String( baos.toByteArray() );
+            }   // end catch
+        }   // end if: compress
+        
+        // Else, don't compress. Better not to use streams at all then.
+        else
+        {
+            // Convert option to boolean in way that code likes it.
+            boolean breakLines = dontBreakLines == 0;
+            
+            int    len43   = len * 4 / 3;
+            byte[] outBuff = new byte[   ( len43 )                      // Main 4:3
+                                       + ( (len % 3) &gt; 0 ? 4 : 0 )      // Account for padding
+                                       + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines      
+            int d = 0;
+            int e = 0;
+            int len2 = len - 2;
+            int lineLength = 0;
+            for( ; d &lt; len2; d+=3, e+=4 )
+            {
+                encode3to4( source, d+off, 3, outBuff, e, options );
+
+                lineLength += 4;
+                if( breakLines &amp;&amp; lineLength == MAX_LINE_LENGTH )
+                {   
+                    outBuff[e+4] = NEW_LINE;
+                    e++;
+                    lineLength = 0;
+                }   // end if: end of line
+            }   // en dfor: each piece of array
+
+            if( d &lt; len )
+            {
+                encode3to4( source, d+off, len - d, outBuff, e, options );
+                e += 4;
+            }   // end if: some padding needed
+
+            
+            // Return value according to relevant encoding.
+            try
+            {
+                return new String( outBuff, 0, e, PREFERRED_ENCODING );
+            }   // end try
+            catch (java.io.UnsupportedEncodingException uue)
+            {
+                return new String( outBuff, 0, e );
+            }   // end catch
+            
+        }   // end else: don't compress
+        
+    }   // end encodeBytes
+    
+
+    
+    
+    
+/* ********  D E C O D I N G   M E T H O D S  ******** */
+    
+    
+    /**
+     * Decodes four bytes from array &lt;var&gt;source&lt;/var&gt;
+     * and writes the resulting bytes (up to three of them)
+     * to &lt;var&gt;destination&lt;/var&gt;.
+     * The source and destination arrays can be manipulated
+     * anywhere along their length by specifying 
+     * &lt;var&gt;srcOffset&lt;/var&gt; and &lt;var&gt;destOffset&lt;/var&gt;.
+     * This method does not check to make sure your arrays
+     * are large enough to accomodate &lt;var&gt;srcOffset&lt;/var&gt; + 4 for
+     * the &lt;var&gt;source&lt;/var&gt; array or &lt;var&gt;destOffset&lt;/var&gt; + 3 for
+     * the &lt;var&gt;destination&lt;/var&gt; array.
+     * This method returns the actual number of bytes that 
+     * were converted from the Base64Coder encoding.
+	 * &lt;p&gt;This is the lowest level of the decoding methods with
+	 * all possible parameters.&lt;/p&gt;
+     * 
+     *
+     * @param source the array to convert
+     * @param srcOffset the index where conversion begins
+     * @param destination the array to hold the conversion
+     * @param destOffset the index where output will be put
+	 * @param options alphabet type is pulled from this (standard, url-safe, ordered)
+     * @return the number of decoded bytes converted
+     * @since 1.3
+     */
+    private static int decode4to3( byte[] source, int srcOffset, byte[] destination, int destOffset, int options )
+    {
+		byte[] DECODABET = getDecodabet( options ); 
+	
+        // Example: Dk==
+        if( source[ srcOffset + 2] == EQUALS_SIGN )
+        {
+            // Two ways to do the same thing. Don't know which way I like best.
+            //int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] &lt;&lt; 24 ) &gt;&gt;&gt;  6 )
+            //              | ( ( DECODABET[ source[ srcOffset + 1] ] &lt;&lt; 24 ) &gt;&gt;&gt; 12 );
+            int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] &amp; 0xFF ) &lt;&lt; 18 )
+                          | ( ( DECODABET[ source[ srcOffset + 1] ] &amp; 0xFF ) &lt;&lt; 12 );
+            
+            destination[ destOffset ] = (byte)( outBuff &gt;&gt;&gt; 16 );
+            return 1;
+        }
+        
+        // Example: DkL=
+        else if( source[ srcOffset + 3 ] == EQUALS_SIGN )
+        {
+            // Two ways to do the same thing. Don't know which way I like best.
+            //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] &lt;&lt; 24 ) &gt;&gt;&gt;  6 )
+            //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] &lt;&lt; 24 ) &gt;&gt;&gt; 12 )
+            //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] &lt;&lt; 24 ) &gt;&gt;&gt; 18 );
+            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] &amp; 0xFF ) &lt;&lt; 18 )
+                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] &amp; 0xFF ) &lt;&lt; 12 )
+                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] &amp; 0xFF ) &lt;&lt;  6 );
+            
+            destination[ destOffset     ] = (byte)( outBuff &gt;&gt;&gt; 16 );
+            destination[ destOffset + 1 ] = (byte)( outBuff &gt;&gt;&gt;  8 );
+            return 2;
+        }
+        
+        // Example: DkLE
+        else
+        {
+            try{
+            // Two ways to do the same thing. Don't know which way I like best.
+            //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] &lt;&lt; 24 ) &gt;&gt;&gt;  6 )
+            //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] &lt;&lt; 24 ) &gt;&gt;&gt; 12 )
+            //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] &lt;&lt; 24 ) &gt;&gt;&gt; 18 )
+            //              | ( ( DECODABET[ source[ srcOffset + 3 ] ] &lt;&lt; 24 ) &gt;&gt;&gt; 24 );
+            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] &amp; 0xFF ) &lt;&lt; 18 )
+                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] &amp; 0xFF ) &lt;&lt; 12 )
+                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] &amp; 0xFF ) &lt;&lt;  6)
+                          | ( ( DECODABET[ source[ srcOffset + 3 ] ] &amp; 0xFF )      );
+
+            
+            destination[ destOffset     ] = (byte)( outBuff &gt;&gt; 16 );
+            destination[ destOffset + 1 ] = (byte)( outBuff &gt;&gt;  8 );
+            destination[ destOffset + 2 ] = (byte)( outBuff       );
+
+            return 3;
+            }catch( Exception e){
+                System.out.println(&quot;&quot;+source[srcOffset]+ &quot;: &quot; + ( DECODABET[ source[ srcOffset     ] ]  ) );
+                System.out.println(&quot;&quot;+source[srcOffset+1]+  &quot;: &quot; + ( DECODABET[ source[ srcOffset + 1 ] ]  ) );
+                System.out.println(&quot;&quot;+source[srcOffset+2]+  &quot;: &quot; + ( DECODABET[ source[ srcOffset + 2 ] ]  ) );
+                System.out.println(&quot;&quot;+source[srcOffset+3]+  &quot;: &quot; + ( DECODABET[ source[ srcOffset + 3 ] ]  ) );
+                return -1;
+            }   // end catch
+        }
+    }   // end decodeToBytes
+    
+    
+    
+    
+    /**
+     * Very low-level access to decoding ASCII characters in
+     * the form of a byte array. Does not support automatically
+     * gunzipping or any other &quot;fancy&quot; features.
+     *
+     * @param source The Base64Coder encoded data
+     * @param off    The offset of where to begin decoding
+     * @param len    The length of characters to decode
+     * @return decoded data
+     * @since 1.3
+     */
+    public static byte[] decode( byte[] source, int off, int len, int options )
+    {
+		byte[] DECODABET = getDecodabet( options );
+	
+        int    len34   = len * 3 / 4;
+        byte[] outBuff = new byte[ len34 ]; // Upper limit on size of output
+        int    outBuffPosn = 0;
+        
+        byte[] b4        = new byte[4];
+        int    b4Posn    = 0;
+        int    i         = 0;
+        byte   sbiCrop   = 0;
+        byte   sbiDecode = 0;
+        for( i = off; i &lt; off+len; i++ )
+        {
+            sbiCrop = (byte)(source[i] &amp; 0x7f); // Only the low seven bits
+            sbiDecode = DECODABET[ sbiCrop ];
+            
+            if( sbiDecode &gt;= WHITE_SPACE_ENC ) // White space, Equals sign or better
+            {
+                if( sbiDecode &gt;= EQUALS_SIGN_ENC )
+                {
+                    b4[ b4Posn++ ] = sbiCrop;
+                    if( b4Posn &gt; 3 )
+                    {
+                        outBuffPosn += decode4to3( b4, 0, outBuff, outBuffPosn, options );
+                        b4Posn = 0;
+                        
+                        // If that was the equals sign, break out of 'for' loop
+                        if( sbiCrop == EQUALS_SIGN )
+                            break;
+                    }   // end if: quartet built
+                    
+                }   // end if: equals sign or better
+                
+            }   // end if: white space, equals sign or better
+            else
+            {
+                System.err.println( &quot;Bad Base64Coder input character at &quot; + i + &quot;: &quot; + source[i] + &quot;(decimal)&quot; );
+                return null;
+            }   // end else: 
+        }   // each input character
+                                   
+        byte[] out = new byte[ outBuffPosn ];
+        System.arraycopy( outBuff, 0, out, 0, outBuffPosn ); 
+        return out;
+    }   // end decode
+    
+    
+	
+	
+    /**
+     * Decodes data from Base64Coder notation, automatically
+     * detecting gzip-compressed data and decompressing it.
+     *
+     * @param s the string to decode
+     * @return the decoded data
+     * @since 1.4
+     */
+    public static byte[] decode( String s )
+	{
+		return decode( s, NO_OPTIONS );
+	}
+    
+    
+    /**
+     * Decodes data from Base64Coder notation, automatically
+     * detecting gzip-compressed data and decompressing it.
+     *
+     * @param s the string to decode
+	 * @param options encode options such as URL_SAFE
+     * @return the decoded data
+     * @since 1.4
+     */
+    public static byte[] decode( String s, int options )
+    {   
+        byte[] bytes;
+        try
+        {
+            bytes = s.getBytes( PREFERRED_ENCODING );
+        }   // end try
+        catch( java.io.UnsupportedEncodingException uee )
+        {
+            bytes = s.getBytes();
+        }   // end catch
+		//&lt;/change&gt;
+        
+        // Decode
+        bytes = decode( bytes, 0, bytes.length, options );
+        
+        
+        // Check to see if it's gzip-compressed
+        // GZIP Magic Two-Byte Number: 0x8b1f (35615)
+        if( bytes != null &amp;&amp; bytes.length &gt;= 4 )
+        {
+            
+            int head = ((int)bytes[0] &amp; 0xff) | ((bytes[1] &lt;&lt; 8) &amp; 0xff00);       
+            if( java.util.zip.GZIPInputStream.GZIP_MAGIC == head ) 
+            {
+                java.io.ByteArrayInputStream  bais = null;
+                java.util.zip.GZIPInputStream gzis = null;
+                java.io.ByteArrayOutputStream baos = null;
+                byte[] buffer = new byte[2048];
+                int    length = 0;
+
+                try
+                {
+                    baos = new java.io.ByteArrayOutputStream();
+                    bais = new java.io.ByteArrayInputStream( bytes );
+                    gzis = new java.util.zip.GZIPInputStream( bais );
+
+                    while( ( length = gzis.read( buffer ) ) &gt;= 0 )
+                    {
+                        baos.write(buffer,0,length);
+                    }   // end while: reading input
+
+                    // No error? Get new bytes.
+                    bytes = baos.toByteArray();
+
+                }   // end try
+                catch( java.io.IOException e )
+                {
+                    // Just return originally-decoded bytes
+                }   // end catch
+                finally
+                {
+                    try{ baos.close(); } catch( Exception e ){}
+                    try{ gzis.close(); } catch( Exception e ){}
+                    try{ bais.close(); } catch( Exception e ){}
+                }   // end finally
+
+            }   // end if: gzipped
+        }   // end if: bytes.length &gt;= 2
+        
+        return bytes;
+    }   // end decode
+
+
+    
+
+    /**
+     * Attempts to decode Base64Coder data and deserialize a Java
+     * Object within. Returns &lt;tt&gt;null&lt;/tt&gt; if there was an error.
+     *
+     * @param encodedObject The Base64Coder data to decode
+     * @return The decoded and deserialized object
+     * @since 1.5
+     */
+    public static Object decodeToObject( String encodedObject )
+    {
+        // Decode and gunzip if necessary
+        byte[] objBytes = decode( encodedObject );
+        
+        java.io.ByteArrayInputStream  bais = null;
+        java.io.ObjectInputStream     ois  = null;
+        Object obj = null;
+        
+        try
+        {
+            bais = new java.io.ByteArrayInputStream( objBytes );
+            ois  = new java.io.ObjectInputStream( bais );
+        
+            obj = ois.readObject();
+        }   // end try
+        catch( java.io.IOException e )
+        {
+            e.printStackTrace();
+            obj = null;
+        }   // end catch
+        catch( java.lang.ClassNotFoundException e )
+        {
+            e.printStackTrace();
+            obj = null;
+        }   // end catch
+        finally
+        {
+            try{ bais.close(); } catch( Exception e ){}
+            try{ ois.close();  } catch( Exception e ){}
+        }   // end finally
+        
+        return obj;
+    }   // end decodeObject
+    
+    
+    
+    /**
+     * Convenience method for encoding data to a file.
+     *
+     * @param dataToEncode byte array of data to encode in Base64Coder form
+     * @param filename Filename for saving encoded data
+     * @return &lt;tt&gt;true&lt;/tt&gt; if successful, &lt;tt&gt;false&lt;/tt&gt; otherwise
+     *
+     * @since 2.1
+     */
+    public static boolean encodeToFile( byte[] dataToEncode, String filename )
+    {
+        boolean success = false;
+        Base64Coder.OutputStream bos = null;
+        try
+        {
+            bos = new Base64Coder.OutputStream( 
+                      new java.io.FileOutputStream( filename ), Base64Coder.ENCODE );
+            bos.write( dataToEncode );
+            success = true;
+        }   // end try
+        catch( java.io.IOException e )
+        {
+            
+            success = false;
+        }   // end catch: IOException
+        finally
+        {
+            try{ bos.close(); } catch( Exception e ){}
+        }   // end finally
+        
+        return success;
+    }   // end encodeToFile
+    
+    
+    /**
+     * Convenience method for decoding data to a file.
+     *
+     * @param dataToDecode Base64Coder-encoded data as a string
+     * @param filename Filename for saving decoded data
+     * @return &lt;tt&gt;true&lt;/tt&gt; if successful, &lt;tt&gt;false&lt;/tt&gt; otherwise
+     *
+     * @since 2.1
+     */
+    public static boolean decodeToFile( String dataToDecode, String filename )
+    {
+        boolean success = false;
+        Base64Coder.OutputStream bos = null;
+        try
+        {
+                bos = new Base64Coder.OutputStream( 
+                          new java.io.FileOutputStream( filename ), Base64Coder.DECODE );
+                bos.write( dataToDecode.getBytes( PREFERRED_ENCODING ) );
+                success = true;
+        }   // end try
+        catch( java.io.IOException e )
+        {
+            success = false;
+        }   // end catch: IOException
+        finally
+        {
+                try{ bos.close(); } catch( Exception e ){}
+        }   // end finally
+        
+        return success;
+    }   // end decodeToFile
+    
+    
+    
+    
+    /**
+     * Convenience method for reading a Base64Coder-encoded
+     * file and decoding it.
+     *
+     * @param filename Filename for reading encoded data
+     * @return decoded byte array or null if unsuccessful
+     *
+     * @since 2.1
+     */
+    public static byte[] decodeFromFile( String filename )
+    {
+        byte[] decodedData = null;
+        Base64Coder.InputStream bis = null;
+        try
+        {
+            // Set up some useful variables
+            java.io.File file = new java.io.File( filename );
+            byte[] buffer = null;
+            int length   = 0;
+            int numBytes = 0;
+            
+            // Check for size of file
+            if( file.length() &gt; Integer.MAX_VALUE )
+            {
+                System.err.println( &quot;File is too big for this convenience method (&quot; + file.length() + &quot; bytes).&quot; );
+                return null;
+            }   // end if: file too big for int index
+            buffer = new byte[ (int)file.length() ];
+            
+            // Open a stream
+            bis = new Base64Coder.InputStream( 
+                      new java.io.BufferedInputStream( 
+                      new java.io.FileInputStream( file ) ), Base64Coder.DECODE );
+            
+            // Read until done
+            while( ( numBytes = bis.read( buffer, length, 4096 ) ) &gt;= 0 )
+                length += numBytes;
+            
+            // Save in a variable to return
+            decodedData = new byte[ length ];
+            System.arraycopy( buffer, 0, decodedData, 0, length );
+            
+        }   // end try
+        catch( java.io.IOException e )
+        {
+            System.err.println( &quot;Error decoding from file &quot; + filename );
+        }   // end catch: IOException
+        finally
+        {
+            try{ bis.close(); } catch( Exception e) {}
+        }   // end finally
+        
+        return decodedData;
+    }   // end decodeFromFile
+    
+    
+    
+    /**
+     * Convenience method for reading a binary file
+     * and Base64Coder-encoding it.
+     *
+     * @param filename Filename for reading binary data
+     * @return Base64Coder-encoded string or null if unsuccessful
+     *
+     * @since 2.1
+     */
+    public static String encodeFromFile( String filename )
+    {
+        String encodedData = null;
+        Base64Coder.InputStream bis = null;
+        try
+        {
+            // Set up some useful variables
+            java.io.File file = new java.io.File( filename );
+            byte[] buffer = new byte[ Math.max((int)(file.length() * 1.4),40) ]; // Need max() for math on small files (v2.2.1)
+            int length   = 0;
+            int numBytes = 0;
+            
+            // Open a stream
+            bis = new Base64Coder.InputStream( 
+                      new java.io.BufferedInputStream( 
+                      new java.io.FileInputStream( file ) ), Base64Coder.ENCODE );
+            
+            // Read until done
+            while( ( numBytes = bis.read( buffer, length, 4096 ) ) &gt;= 0 )
+                length += numBytes;
+            
+            // Save in a variable to return
+            encodedData = new String( buffer, 0, length, Base64Coder.PREFERRED_ENCODING );
+                
+        }   // end try
+        catch( java.io.IOException e )
+        {
+            System.err.println( &quot;Error encoding from file &quot; + filename );
+        }   // end catch: IOException
+        finally
+        {
+            try{ bis.close(); } catch( Exception e) {}
+        }   // end finally
+        
+        return encodedData;
+        }   // end encodeFromFile
+    
+    
+    
+    
+    /**
+     * Reads &lt;tt&gt;infile&lt;/tt&gt; and encodes it to &lt;tt&gt;outfile&lt;/tt&gt;.
+     *
+     * @param infile Input file
+     * @param outfile Output file
+     * @return true if the operation is successful
+     * @since 2.2
+     */
+    public static boolean encodeFileToFile( String infile, String outfile )
+    {
+        boolean success = false;
+        java.io.InputStream in = null;
+        java.io.OutputStream out = null;
+        try{
+            in  = new Base64Coder.InputStream( 
+                      new java.io.BufferedInputStream( 
+                      new java.io.FileInputStream( infile ) ), 
+                      Base64Coder.ENCODE );
+            out = new java.io.BufferedOutputStream( new java.io.FileOutputStream( outfile ) );
+            byte[] buffer = new byte[65536]; // 64K
+            int read = -1;
+            while( ( read = in.read(buffer) ) &gt;= 0 ){
+                out.write( buffer,0,read );
+            }   // end while: through file
+            success = true;
+        } catch( java.io.IOException exc ){
+            exc.printStackTrace();
+        } finally{
+            try{ in.close();  } catch( Exception exc ){}
+            try{ out.close(); } catch( Exception exc ){}
+        }   // end finally
+        
+        return success;
+    }   // end encodeFileToFile
+    
+    
+    
+    /**
+     * Reads &lt;tt&gt;infile&lt;/tt&gt; and decodes it to &lt;tt&gt;outfile&lt;/tt&gt;.
+     *
+     * @param infile Input file
+     * @param outfile Output file
+     * @return true if the operation is successful
+     * @since 2.2
+     */
+    public static boolean decodeFileToFile( String infile, String outfile )
+    {
+        boolean success = false;
+        java.io.InputStream in = null;
+        java.io.OutputStream out = null;
+        try{
+            in  = new Base64Coder.InputStream( 
+                      new java.io.BufferedInputStream( 
+                      new java.io.FileInputStream( infile ) ), 
+                      Base64Coder.DECODE );
+            out = new java.io.BufferedOutputStream( new java.io.FileOutputStream( outfile ) );
+            byte[] buffer = new byte[65536]; // 64K
+            int read = -1;
+            while( ( read = in.read(buffer) ) &gt;= 0 ){
+                out.write( buffer,0,read );
+            }   // end while: through file
+            success = true;
+        } catch( java.io.IOException exc ){
+            exc.printStackTrace();
+        } finally{
+            try{ in.close();  } catch( Exception exc ){}
+            try{ out.close(); } catch( Exception exc ){}
+        }   // end finally
+        
+        return success;
+    }   // end decodeFileToFile
+    
+    
+    /* ********  I N N E R   C L A S S   I N P U T S T R E A M  ******** */
+    
+    
+    
+    /**
+     * A {@link Base64Coder.InputStream} will read data from another
+     * &lt;tt&gt;java.io.InputStream&lt;/tt&gt;, given in the constructor,
+     * and encode/decode to/from Base64Coder notation on the fly.
+     *
+     * @see Base64Coder
+     * @since 1.3
+     */
+    public static class InputStream extends java.io.FilterInputStream
+    {
+        private boolean encode;         // Encoding or decoding
+        private int     position;       // Current position in the buffer
+        private byte[]  buffer;         // Small buffer holding converted data
+        private int     bufferLength;   // Length of buffer (3 or 4)
+        private int     numSigBytes;    // Number of meaningful bytes in the buffer
+        private int     lineLength;
+        private boolean breakLines;     // Break lines at less than 80 characters
+		private int     options;        // Record options used to create the stream.
+		private byte[]  alphabet;	    // Local copies to avoid extra method calls
+		private byte[]  decodabet;		// Local copies to avoid extra method calls
+        
+        
+        /**
+         * Constructs a {@link Base64Coder.InputStream} in DECODE mode.
+         *
+         * @param in the &lt;tt&gt;java.io.InputStream&lt;/tt&gt; from which to read data.
+         * @since 1.3
+         */
+        public InputStream( java.io.InputStream in )
+        {   
+            this( in, DECODE );
+        }   // end constructor
+        
+        
+        /**
+         * Constructs a {@link Base64Coder.InputStream} in
+         * either ENCODE or DECODE mode.
+         * &lt;p&gt;
+         * Valid options:&lt;pre&gt;
+         *   ENCODE or DECODE: Encode or Decode as data is read.
+         *   DONT_BREAK_LINES: don't break lines at 76 characters
+         *     (only meaningful when encoding)
+         *     &lt;i&gt;Note: Technically, this makes your encoding non-compliant.&lt;/i&gt;
+         * &lt;/pre&gt;
+         * &lt;p&gt;
+         * Example: &lt;code&gt;new Base64Coder.InputStream( in, Base64Coder.DECODE )&lt;/code&gt;
+         *
+         *
+         * @param in the &lt;tt&gt;java.io.InputStream&lt;/tt&gt; from which to read data.
+         * @param options Specified options
+         * @see Base64Coder#ENCODE
+         * @see Base64Coder#DECODE
+         * @see Base64Coder#DONT_BREAK_LINES
+         * @since 2.0
+         */
+        public InputStream( java.io.InputStream in, int options )
+        {   
+            super( in );
+            this.breakLines   = (options &amp; DONT_BREAK_LINES) != DONT_BREAK_LINES;
+            this.encode       = (options &amp; ENCODE) == ENCODE;
+            this.bufferLength = encode ? 4 : 3;
+            this.buffer       = new byte[ bufferLength ];
+            this.position     = -1;
+            this.lineLength   = 0;
+			this.options      = options; // Record for later, mostly to determine which alphabet to use
+			this.alphabet     = getAlphabet(options);
+			this.decodabet    = getDecodabet(options);
+        }   // end constructor
+        
+        /**
+         * Reads enough of the input stream to convert
+         * to/from Base64Coder and returns the next byte.
+         *
+         * @return next byte
+         * @since 1.3
+         */
+        public int read() throws java.io.IOException 
+        { 
+            // Do we need to get data?
+            if( position &lt; 0 )
+            {
+                if( encode )
+                {
+                    byte[] b3 = new byte[3];
+                    int numBinaryBytes = 0;
+                    for( int i = 0; i &lt; 3; i++ )
+                    {
+                        try
+                        { 
+                            int b = in.read();
+                            
+                            // If end of stream, b is -1.
+                            if( b &gt;= 0 )
+                            {
+                                b3[i] = (byte)b;
+                                numBinaryBytes++;
+                            }   // end if: not end of stream
+                            
+                        }   // end try: read
+                        catch( java.io.IOException e )
+                        {   
+                            // Only a problem if we got no data at all.
+                            if( i == 0 )
+                                throw e;
+                            
+                        }   // end catch
+                    }   // end for: each needed input byte
+                    
+                    if( numBinaryBytes &gt; 0 )
+                    {
+                        encode3to4( b3, 0, numBinaryBytes, buffer, 0, options );
+                        position = 0;
+                        numSigBytes = 4;
+                    }   // end if: got data
+                    else
+                    {
+                        return -1;
+                    }   // end else
+                }   // end if: encoding
+                
+                // Else decoding
+                else
+                {
+                    byte[] b4 = new byte[4];
+                    int i = 0;
+                    for( i = 0; i &lt; 4; i++ )
+                    {
+                        // Read four &quot;meaningful&quot; bytes:
+                        int b = 0;
+                        do{ b = in.read(); }
+                        while( b &gt;= 0 &amp;&amp; decodabet[ b &amp; 0x7f ] &lt;= WHITE_SPACE_ENC );
+                        
+                        if( b &lt; 0 )
+                            break; // Reads a -1 if end of stream
+                        
+                        b4[i] = (byte)b;
+                    }   // end for: each needed input byte
+                    
+                    if( i == 4 )
+                    {
+                        numSigBytes = decode4to3( b4, 0, buffer, 0, options );
+                        position = 0;
+                    }   // end if: got four characters
+                    else if( i == 0 ){
+                        return -1;
+                    }   // end else if: also padded correctly
+                    else
+                    {
+                        // Must have broken out from above.
+                        throw new java.io.IOException( &quot;Improperly padded Base64Coder input.&quot; );
+                    }   // end 
+                    
+                }   // end else: decode
+            }   // end else: get data
+            
+            // Got data?
+            if( position &gt;= 0 )
+            {
+                // End of relevant data?
+                if( /*!encode &amp;&amp;*/ position &gt;= numSigBytes )
+                    return -1;
+                
+                if( encode &amp;&amp; breakLines &amp;&amp; lineLength &gt;= MAX_LINE_LENGTH )
+                {
+                    lineLength = 0;
+                    return '\n';
+                }   // end if
+                else
+                {
+                    lineLength++;   // This isn't important when decoding
+                                    // but throwing an extra &quot;if&quot; seems
+                                    // just as wasteful.
+                    
+                    int b = buffer[ position++ ];
+
+                    if( position &gt;= bufferLength )
+                        position = -1;
+
+                    return b &amp; 0xFF; // This is how you &quot;cast&quot; a byte that's
+                                     // intended to be unsigned.
+                }   // end else
+            }   // end if: position &gt;= 0
+            
+            // Else error
+            else
+            {   
+                // When JDK1.4 is more accepted, use an assertion here.
+                throw new java.io.IOException( &quot;Error in Base64Coder code reading stream.&quot; );
+            }   // end else
+        }   // end read
+        
+        
+        /**
+         * Calls {@link #read()} repeatedly until the end of stream
+         * is reached or &lt;var&gt;len&lt;/var&gt; bytes are read.
+         * Returns number of bytes read into array or -1 if
+         * end of stream is encountered.
+         *
+         * @param dest array to hold values
+         * @param off offset for array
+         * @param len max number of bytes to read into array
+         * @return bytes read into array or -1 if end of stream is encountered.
+         * @since 1.3
+         */
+        public int read( byte[] dest, int off, int len ) throws java.io.IOException
+        {
+            int i;
+            int b;
+            for( i = 0; i &lt; len; i++ )
+            {
+                b = read();
+                
+                //if( b &lt; 0 &amp;&amp; i == 0 )
+                //    return -1;
+                
+                if( b &gt;= 0 )
+                    dest[off + i] = (byte)b;
+                else if( i == 0 )
+                    return -1;
+                else
+                    break; // Out of 'for' loop
+            }   // end for: each byte read
+            return i;
+        }   // end read
+        
+    }   // end inner class InputStream
+    
+    
+    
+    
+    
+    
+    /* ********  I N N E R   C L A S S   O U T P U T S T R E A M  ******** */
+    
+    
+    
+    /**
+     * A {@link Base64Coder.OutputStream} will write data to another
+     * &lt;tt&gt;java.io.OutputStream&lt;/tt&gt;, given in the constructor,
+     * and encode/decode to/from Base64Coder notation on the fly.
+     *
+     * @see Base64Coder
+     * @since 1.3
+     */
+    public static class OutputStream extends java.io.FilterOutputStream
+    {
+        private boolean encode;
+        private int     position;
+        private byte[]  buffer;
+        private int     bufferLength;
+        private int     lineLength;
+        private boolean breakLines;
+        private byte[]  b4; // Scratch used in a few places
+        private boolean suspendEncoding;
+		private int options; // Record for later
+		private byte[]  alphabet;	    // Local copies to avoid extra method calls
+		private byte[]  decodabet;		// Local copies to avoid extra method calls
+        
+        /**
+         * Constructs a {@link Base64Coder.OutputStream} in ENCODE mode.
+         *
+         * @param out the &lt;tt&gt;java.io.OutputStream&lt;/tt&gt; to which data will be written.
+         * @since 1.3
+         */
+        public OutputStream( java.io.OutputStream out )
+        {   
+            this( out, ENCODE );
+        }   // end constructor
+        
+        
+        /**
+         * Constructs a {@link Base64Coder.OutputStream} in
+         * either ENCODE or DECODE mode.
+         * &lt;p&gt;
+         * Valid options:&lt;pre&gt;
+         *   ENCODE or DECODE: Encode or Decode as data is read.
+         *   DONT_BREAK_LINES: don't break lines at 76 characters
+         *     (only meaningful when encoding)
+         *     &lt;i&gt;Note: Technically, this makes your encoding non-compliant.&lt;/i&gt;
+         * &lt;/pre&gt;
+         * &lt;p&gt;
+         * Example: &lt;code&gt;new Base64Coder.OutputStream( out, Base64Coder.ENCODE )&lt;/code&gt;
+         *
+         * @param out the &lt;tt&gt;java.io.OutputStream&lt;/tt&gt; to which data will be written.
+         * @param options Specified options.
+         * @see Base64Coder#ENCODE
+         * @see Base64Coder#DECODE
+         * @see Base64Coder#DONT_BREAK_LINES
+         * @since 1.3
+         */
+        public OutputStream( java.io.OutputStream out, int options )
+        {   
+            super( out );
+            this.breakLines   = (options &amp; DONT_BREAK_LINES) != DONT_BREAK_LINES;
+            this.encode       = (options &amp; ENCODE) == ENCODE;
+            this.bufferLength = encode ? 3 : 4;
+            this.buffer       = new byte[ bufferLength ];
+            this.position     = 0;
+            this.lineLength   = 0;
+            this.suspendEncoding = false;
+            this.b4           = new byte[4];
+			this.options      = options;
+			this.alphabet     = getAlphabet(options);
+			this.decodabet    = getDecodabet(options);
+        }   // end constructor
+        
+        
+        /**
+         * Writes the byte to the output stream after
+         * converting to/from Base64Coder notation.
+         * When encoding, bytes are buffered three
+         * at a time before the output stream actually
+         * gets a write() call.
+         * When decoding, bytes are buffered four
+         * at a time.
+         *
+         * @param theByte the byte to write
+         * @since 1.3
+         */
+        public void write(int theByte) throws java.io.IOException
+        {
+            // Encoding suspended?
+            if( suspendEncoding )
+            {
+                super.out.write( theByte );
+                return;
+            }   // end if: supsended
+            
+            // Encode?
+            if( encode )
+            {
+                buffer[ position++ ] = (byte)theByte;
+                if( position &gt;= bufferLength )  // Enough to encode.
+                {
+                    out.write( encode3to4( b4, buffer, bufferLength, options ) );
+
+                    lineLength += 4;
+                    if( breakLines &amp;&amp; lineLength &gt;= MAX_LINE_LENGTH )
+                    {
+                        out.write( NEW_LINE );
+                        lineLength = 0;
+                    }   // end if: end of line
+
+                    position = 0;
+                }   // end if: enough to output
+            }   // end if: encoding
+
+            // Else, Decoding
+            else
+            {
+                // Meaningful Base64Coder character?
+                if( decodabet[ theByte &amp; 0x7f ] &gt; WHITE_SPACE_ENC )
+                {
+                    buffer[ position++ ] = (byte)theByte;
+                    if( position &gt;= bufferLength )  // Enough to output.
+                    {
+                        int len = Base64Coder.decode4to3( buffer, 0, b4, 0, options );
+                        out.write( b4, 0, len );
+                        //out.write( Base64Coder.decode4to3( buffer ) );
+                        position = 0;
+                    }   // end if: enough to output
+                }   // end if: meaningful Base64Coder character
+                else if( decodabet[ theByte &amp; 0x7f ] != WHITE_SPACE_ENC )
+                {
+                    throw new java.io.IOException( &quot;Invalid character in Base64Coder data.&quot; );
+                }   // end else: not white space either
+            }   // end else: decoding
+        }   // end write
+        
+        
+        
+        /**
+         * Calls {@link #write(int)} repeatedly until &lt;var&gt;len&lt;/var&gt; 
+         * bytes are written.
+         *
+         * @param theBytes array from which to read bytes
+         * @param off offset for array
+         * @param len max number of bytes to read into array
+         * @since 1.3
+         */
+        public void write( byte[] theBytes, int off, int len ) throws java.io.IOException
+        {
+            // Encoding suspended?
+            if( suspendEncoding )
+            {
+                super.out.write( theBytes, off, len );
+                return;
+            }   // end if: supsended
+            
+            for( int i = 0; i &lt; len; i++ )
+            {
+                write( theBytes[ off + i ] );
+            }   // end for: each byte written
+            
+        }   // end write
+        
+        
+        
+        /**
+         * Method added by PHIL. [Thanks, PHIL. -Rob]
+         * This pads the buffer without closing the stream.
+         */
+        public void flushBase64Coder() throws java.io.IOException 
+        {
+            if( position &gt; 0 )
+            {
+                if( encode )
+                {
+                    out.write( encode3to4( b4, buffer, position, options ) );
+                    position = 0;
+                }   // end if: encoding
+                else
+                {
+                    throw new java.io.IOException( &quot;Base64Coder input not properly padded.&quot; );
+                }   // end else: decoding
+            }   // end if: buffer partially full
+
+        }   // end flush
+
+        
+        /** 
+         * Flushes and closes (I think, in the superclass) the stream. 
+         *
+         * @since 1.3
+         */
+        public void close() throws java.io.IOException
+        {
+            // 1. Ensure that pending characters are written
+            flushBase64Coder();
+
+            // 2. Actually close the stream
+            // Base class both flushes and closes.
+            super.close();
+            
+            buffer = null;
+            out    = null;
+        }   // end close
+        
+        
+        
+        /**
+         * Suspends encoding of the stream.
+         * May be helpful if you need to embed a piece of
+         * Base64Coder0-encoded data in a stream.
+         *
+         * @since 1.5.1
+         */
+        public void suspendEncoding() throws java.io.IOException 
+        {
+            flushBase64Coder();
+            this.suspendEncoding = true;
+        }   // end suspendEncoding
+        
+        
+        /**
+         * Resumes encoding of the stream.
+         * May be helpful if you need to embed a piece of
+         * Base64Coder0-encoded data in a stream.
+         *
+         * @since 1.5.1
+         */
+        public void resumeEncoding()
+        {
+            this.suspendEncoding = false;
+        }   // end resumeEncoding
+        
+        
+        
+    }   // end inner class OutputStream
+    
+    
+}   // end class Base64Coder

Modified: trunk/ims-communicator/src/net/java/sip/communicator/sip/security/Milenage.java
===================================================================
--- trunk/ims-communicator/src/net/java/sip/communicator/sip/security/Milenage.java	2007-12-05 16:59:53 UTC (rev 88)
+++ trunk/ims-communicator/src/net/java/sip/communicator/sip/security/Milenage.java	2007-12-11 17:46:19 UTC (rev 89)
@@ -59,7 +59,7 @@
 		throws InvalidKeyException, ArrayIndexOutOfBoundsException
     {
 		try {
-			console.logEntry();
+			//console.logEntry();
 		
 			rijndael.init(secretKey);
 			// op is set in the properties file (OPERATOR_ID) 
@@ -102,7 +102,7 @@
 	        return mac;
 		}
 		finally {
-			console.logExit();
+			//console.logExit();
 		}
     } /* end of function f1 */
 
@@ -122,7 +122,7 @@
     	throws InvalidKeyException, ArrayIndexOutOfBoundsException
     {
     	try{
-    		console.logEntry();
+    		//console.logEntry();
     		
 	    	rijndael.init(secretKey);
 	        byte[] temp = new byte[16];
@@ -152,7 +152,7 @@
 	        return res;
     	}
     	finally {
-    		console.logExit();
+    		//console.logExit();
     	}
     } /* end of function f2 */
 
@@ -216,7 +216,7 @@
     	throws InvalidKeyException, ArrayIndexOutOfBoundsException
     {
     	try {
-    		console.logEntry();
+    		//console.logEntry();
 	    		
 	    	rijndael.init(secretKey);
 	        byte[] temp = new byte[16];
@@ -247,7 +247,7 @@
 	        return ik;
     	}
     	finally {
-    		console.logExit();
+    		//console.logExit();
     	}
     } /* end of function f4 */
 
@@ -268,7 +268,7 @@
     	throws InvalidKeyException, ArrayIndexOutOfBoundsException
     {
     	try {
-    		console.logEntry();
+    		//console.logEntry();
 
     		rijndael.init(secretKey);
 	        byte[] temp = new byte[16];
@@ -298,7 +298,7 @@
 	        return ak;
     	}
     	finally {
-    		console.logExit();
+    		//console.logExit();
     	}
     } /* end of function f5 */
 
@@ -423,7 +423,7 @@
     	throws InvalidKeyException, ArrayIndexOutOfBoundsException       
     {
     	try {
-	    	console.logEntry();
+	    	//console.logEntry();
 	    	
 	    	rijndael.init(secretKey);        
 	        byte[] byteOp_c = rijndael.encrypt(op);
@@ -434,7 +434,7 @@
 	        return op_c;
     	}
     	finally{
-    		console.logExit();
+    		//console.logExit();
     	}
     } /* end of function computeOpC */
 }

Modified: trunk/ims-communicator/src/net/java/sip/communicator/sip/security/SipSecurityManager.java
===================================================================
--- trunk/ims-communicator/src/net/java/sip/communicator/sip/security/SipSecurityManager.java	2007-12-05 16:59:53 UTC (rev 88)
+++ trunk/ims-communicator/src/net/java/sip/communicator/sip/security/SipSecurityManager.java	2007-12-11 17:46:19 UTC (rev 89)
@@ -950,8 +950,8 @@
 	    		}
 	    		else
 	    		{
-	    			console.debug(&quot;Unable to get the AKA RES... using MD5&quot;);
-	    			//throw new SecurityException(&quot;Unable to get the AKA RES!&quot;);
+	    			//console.debug(&quot;Unable to get the AKA RES... using MD5&quot;);
+	    			throw new SecurityException(&quot;Unable to get the AKA RES!&quot;);
 	    		}
 	    	}
 	    	//console.debug(&quot;algorithm = &quot; + algorithm);
@@ -980,7 +980,7 @@
 	        }
 	        
 	        // //
-	        console.debug(&quot;response RES hex = &quot; + response + &quot; (&quot;+response.length()+&quot;bytes)&quot;);
+	        console.debug(&quot;response hex = &quot; + response + &quot; (&quot;+response.length()+&quot;bytes)&quot;);
 	        
 	        
 	        AuthorizationHeader authorization = null;
@@ -1029,9 +1029,9 @@
 	
 	            
 	            // issued by Miguel Freitas (IT) PT-Inovacao //
-	            // HTTP AKA synchronisation
+	            // HTTP AKA synchronisation failure
 	            if (akaRes != null &amp;&amp; akaRes.getAUTS() != null
-	            		&amp;&amp; akaRes.getAUTS().length&gt;0)
+	            		&amp;&amp; akaRes.getAUTS().length()&gt;0)
 	            {
 	            	authorization.setParameter(&quot;auts&quot;,
 	            			new String(&quot;\&quot;&quot; + akaRes.getAUTS() + &quot;\&quot;&quot;));

Modified: trunk/releases/ims-communicator-linux.zip
===================================================================
(Binary files differ)

Modified: trunk/releases/ims-communicator-windows.zip
===================================================================
(Binary files differ)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000076.html">[Imscommunicator-dev] r88 - in trunk:	ims-communicator/src/net/java/sip/communicator/media	ims-communicator/src/net/java/sip/communicator/sip	ims-communicator/src/net/java/sip/communicator/sip/reg	ims-communicator/src/net/java/sip/communicator/sip/security releases
</A></li>
	<LI>Next message: <A HREF="000077.html">[Imscommunicator-dev] r90 - trunk/lib
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#78">[ date ]</a>
              <a href="thread.html#78">[ thread ]</a>
              <a href="subject.html#78">[ subject ]</a>
              <a href="author.html#78">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/imscommunicator-dev">More information about the Imscommunicator-dev
mailing list</a><br>
</body></html>
